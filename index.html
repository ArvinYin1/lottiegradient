<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gradient Editor</title>
    <!-- Add lottie-web library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/bodymovin/5.12.2/lottie.min.js"></script>
    <!-- Add Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Add highlight.js for syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <!-- Add Monaco Editor for enhanced JSON editing -->
    <link rel="stylesheet" data-name="vs/editor/editor.main" href="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.41.0/min/vs/editor/editor.main.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.41.0/min/vs/loader.js"></script>
    <style>
        /* CSS Variables for Theme Colors */
        :root {
            /* Light Theme */
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-tertiary: #fafafa;
            --bg-input: #ffffff;
            --text-primary: #343a40;
            --text-secondary: #6c757d;
            --border-color: #e0e0e0;
            --border-dark: #ddd;
            --btn-primary: #007bff;
            --btn-success: #28a745;
            --btn-danger: #dc3545;
            --btn-secondary: #6c757d;
            --checkered-color: #ccc;
            /* Drag and Drop */
            --drag-over-bg: rgba(0, 123, 255, 0.1);
            --drag-over-border: #007bff;
        }
        
        /* Dark Theme */
        [data-theme="dark"] {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --bg-tertiary: #242424;
            --bg-input: #333333;
            --text-primary: #e0e0e0;
            --text-secondary: #b0b0b0;
            --border-color: #444444;
            --border-dark: #555555;
            --btn-primary: #0069d9;
            --btn-success: #218838;
            --btn-danger: #c82333;
            --btn-secondary: #5a6268;
            --checkered-color: #555555;
            /* Drag and Drop */
            --drag-over-bg: rgba(0, 105, 217, 0.2);
            --drag-over-border: #0069d9;
        }
        
        /* Apply theme variables to all elements */
        * {
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
        }
        
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            height: calc(100vh - 40px);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Lottie Player styles */
        .lottie-player-container {
            margin-top: 0;
            padding: 20px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background-color: var(--bg-tertiary);
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .lottie-player-header {
            margin-bottom: 20px;
        }
        
        .header-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
            gap: 20px;
            flex-wrap: wrap;
        }

        .title-section {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .controls-section {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .file-upload {
            margin: 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px; /* Rounded corners */
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            line-height: 1.2;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-primary {
            background-color: var(--btn-primary);
            color: white;
        }

        .btn-primary:hover {
            background-color: #0056b3;
        }

        .btn-success {
            background-color: var(--btn-success);
            color: white;
        }

        .btn-success:hover {
            background-color: #1e7e34;
        }
        
        .btn-danger {
            background-color: var(--btn-danger);
            color: white;
        }

        .btn-danger:hover {
            background-color: #c82333;
        }

        .btn-sm {
            padding: 4px 10px;
            font-size: 12px;
            border-radius: 4px;
        }
        
        .header-btn {
            height: 36px;
            padding: 0 16px;
            font-size: 14px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            white-space: nowrap;
            border-radius: 6px; /* Ensure rounded corners */
        }

        .header-btn i {
            font-size: 14px;
            width: 16px; /* Ensure fixed width for icons to prevent layout shift */
            text-align: center;
        }

        .file-input-label {
             /* Styles will be replaced by general button styles below */
             margin-right: 0;
             line-height: 1.2;
        }
        
        .file-input {
            display: none;
        }
        
        .export-btn {
             /* Styles will be replaced by general button styles below */
        }
        
        .file-info {
            display: inline-block;
            margin-left: 10px;
            font-style: italic;
            color: var(--text-secondary);
        }
        
        .lottie-animation {
            width: 100%;
            height: 100%; /* Fill available space */
            background-color: var(--bg-primary);
            border: 1px solid var(--border-dark);
            border-radius: 4px;
            margin-top: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            flex: 1;
        }
        
        /* Lottie and JSON Editor layout */
        .lottie-editor-wrapper {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        
        .lottie-player-section {
            flex: 1;
            min-width: 0;
        }
        
        .json-editor-section {
            flex: 1;
            min-width: 0;
        }
        
        /* JSON Editor styles */
        .json-editor-section h3 {
            margin-top: 0;
            margin-bottom: 15px;
        }
        
        .json-editor-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .json-editor-container {
            height: 400px;
            border: 1px solid var(--border-dark);
            border-radius: 4px;
            overflow: hidden;
        }
        
        /* Ensure Monaco Editor container has fixed height */
        #monaco-editor-container {
            width: 100%;
            height: 100%;
        }
        
        #json-editor {
            width: 100%;
            height: 100%;
            padding: 15px;
            border: none;
            resize: none;
            font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
            font-size: 14px;
            line-height: 1.5;
            background-color: var(--bg-input);
            color: var(--text-primary);
            box-sizing: border-box;
        }
        
        #json-editor:focus {
            outline: none;
            box-shadow: inset 0 0 0 2px #007bff;
        }
        
        .btn-flat-primary {
            background-color: var(--btn-primary);
            color: white;
            border: none;
            box-shadow: none !important;
            transform: none !important; /* Disable lift effect */
        }

        .btn-flat-primary:hover {
            background-color: #0056b3;
            transform: none !important;
            box-shadow: none !important;
        }

        /* Button secondary style */
        .btn-secondary {
            background-color: var(--btn-secondary);
            color: white;
        }
        
        /* Playground layout for left preview and right editor */
        .playground-container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            flex: 1;
            min-height: 0; /* Important for nested flex scroll */
        }
        
        /* Left preview section */
        .preview-section {
            flex: 2; /* Increased width for player */
            min-width: 300px;
            background-color: var(--bg-secondary);
            padding: 20px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
        }
        
        .preview-section h3 {
            margin-top: 0;
            margin-bottom: 20px;
        }
        
        /* Right editor section */
        .editor-section {
            flex: 2; /* Increased width to accommodate horizontal layout */
            min-width: 500px;
            display: flex;
            flex-direction: row; /* Changed to row for horizontal layout */
            gap: 20px;
            overflow: hidden; /* Prevent outer scroll */
        }

        .json-editor-section-full {
            display: none;
            /* Moved styles to general structure */
        }
        
        /* Gradient Names section */
        .gradient-names-section {
            background-color: var(--bg-secondary);
            padding: 20px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            flex: 1; /* Take up half width */
            overflow: hidden; /* Contain scroll */
        }
        
        /* Color Editor section */
        .editor-container {
            background-color: var(--bg-secondary);
            padding: 20px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            flex: 1; /* Take up half width */
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #editor-title {
            margin-top: 0;
            margin-bottom: 20px;
            flex-shrink: 0;
        }

        #editor {
            overflow-y: auto; /* Allow scrolling within editor if needed */
            flex: 1;
        }

        /* Generated JSON section */
        .json-viewer {
            display: none;
            /* Moved logic */
        }
        
        /* Main gradient section in the top editor area */
        .main-gradient-section {
            /* Removed max-height */
            overflow: hidden;
            display: flex;
            flex-direction: column;
            flex: 1;
        }
        
        .gradient-names-section h3 {
            margin-top: 0;
            margin-bottom: 10px;
            flex-shrink: 0;
        }
        
        .gradient-search-container {
            margin-bottom: 15px;
            flex-shrink: 0;
            padding: 0 15px;
        }
        
        .gradient-search-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--bg-input);
            color: var(--text-primary);
            font-size: 14px;
            transition: border-color 0.2s ease;
            box-sizing: border-box;
        }
        
        .gradient-search-input:focus {
            outline: none;
            border-color: var(--btn-primary);
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
        }
        
        .gradient-names-list {
            /* Remove fixed height, use flex to fill available space */
            height: auto;
            flex: 1;
            overflow-y: auto;
            background-color: var(--bg-primary);
            border: 1px solid var(--border-dark);
            border-radius: 4px;
            padding: 15px;
        }
        
        .gradient-name-item {
            margin-bottom: 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            overflow: hidden;
            background-color: var(--bg-primary);
        }
        
        .gradient-item-header {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            cursor: pointer;
            background-color: var(--bg-secondary);
            transition: background-color 0.2s;
            text-decoration: none !important; /* Ensure no underline */
        }
        
        .gradient-item-header * {
            text-decoration: none !important;
        }
        
        .gradient-item-header:hover {
            background-color: var(--border-color);
        }
        
        /* Highlight style for selected gradient item */
        .gradient-name-item.selected {
            border-color: var(--btn-primary);
            background-color: rgba(0, 123, 255, 0.1);
        }
        
        .gradient-name-item.selected .gradient-item-header {
            background-color: rgba(0, 123, 255, 0.15);
        }
        
        .gradient-name-index {
            font-weight: bold;
            margin-right: 10px;
            color: var(--btn-primary);
        }
        
        .gradient-name {
            flex: 1;
            cursor: pointer;
            text-decoration: underline;
            color: var(--btn-primary);
        }
        
        .gradient-toggle-icon {
            font-size: 12px;
            color: var(--text-secondary);
            transition: transform 0.2s;
        }
        
        .gradient-expandable-content {
            padding: 15px;
            background-color: var(--bg-tertiary);
            border-top: 1px solid var(--border-color);
        }

        .gradient-editor {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 10px;
            padding: 15px;
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px; /* Rounded corners for the row */
        }
        
        .gradient-editor-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .gradient-editor-row .gradient-editor-label {
            margin: 0;
        }
        
        /* Reduce space between label text and input */
        .gradient-editor-row label.gradient-editor-label {
            margin-right: -7px;
        }
        
        /* Reduce space between input and percentage sign */
        .gradient-editor-row span.gradient-editor-label {
            margin-left: -5px;
        }
        
        .gradient-editor-label {
            font-size: 14px;
            color: var(--text-primary);
            white-space: nowrap;
        }
        
        /* Styles for disabled state */
        .gradient-editor input:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .gradient-editor input:disabled + label,
        .gradient-editor input:disabled ~ label {
            opacity: 0.6;
        }
        
        .btn-delete {
            width: auto;
            margin-left: auto;
        }
        
        .gradient-editor input[type="number"] {
            padding: 4px 2px; /* Reduced padding to make input more compact */
            border: 1px solid var(--border-color);
            border-radius: 6px; /* Rounded corners for inputs */
            background-color: var(--bg-input);
            color: var(--text-primary);
            width: 40px; /* Reduced from 60px to 40px (safer than 30px for readability) */
            font-size: 14px;
            text-align: center; /* Center text for better look in small input */
            -moz-appearance: textfield; /* Hide spinner in Firefox */
        }

        /* Hide spinner in Chrome, Safari, Edge, Opera */
        .gradient-editor input[type="number"]::-webkit-outer-spin-button,
        .gradient-editor input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .gradient-editor input[type="color"] {
            width: 100%;
            height: 34px;
            padding: 2px;
            border: none;
            border-radius: 6px; /* Rounded corners for color picker */
            cursor: pointer;
            background-color: transparent;
        }
        
        .gradient-preview {
            width: 100%;
            height: 34px;
            border-radius: 6px;
            margin-bottom: 15px;
            border: 1px solid var(--border-color);
            /* Ensure the gradient background is properly displayed over the alpha checkered pattern */
            background-size: 100% 100% !important;
            background-repeat: no-repeat !important;
            background-position: 0 0 !important;
        }
        
        .gradient-data {
            margin: 0;
        }
        
        .gradient-data h4 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 14px;
            color: var(--text-primary);
        }
        
        .gradient-data pre {
            margin: 0;
            padding: 10px;
            background-color: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            overflow-x: auto;
            font-size: 12px;
            line-height: 1.4;
        }
        
        /* Lottie animation container */
        .lottie-animation {
            width: 100%;
            height: 400px;
            background-color: var(--bg-primary);
            border: 1px solid var(--border-dark);
            border-radius: 4px;
            margin-top: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .alpha_checkered {
            background-color: transparent !important;
            background-image: linear-gradient(45deg, var(--checkered-color) 25%, transparent 25%), 
                              linear-gradient(-45deg, var(--checkered-color) 25%, transparent 25%), 
                              linear-gradient(45deg, transparent 75%, var(--checkered-color) 75%), 
                              linear-gradient(-45deg, transparent 75%, var(--checkered-color) 75%) !important;
            background-size: 20px 20px !important;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px !important;
        }
        
        /* Drag and Drop Styles */
        .lottie-player-container.drag-over {
            background-color: var(--drag-over-bg);
            border: 2px dashed var(--drag-over-border);
            border-radius: 8px;
            transition: all 0.3s ease;
        }
        
        /* Responsive design */
        @media (max-width: 1024px) {
            .playground-container {
                flex-direction: column;
            }
            
            .preview-section,
            .json-editor-section-full,
            .gradient-names-section {
                min-width: auto;
            }
        }
        
        /* Theme transition for smooth changes */
        html {
            transition: background-color 0.3s ease;
        }
        
        /* Additional styles for dark theme */
        [data-theme="dark"] {
            /* Ensure proper contrast for text inputs */
            input[type="text"],
            input[type="number"],
            textarea {
                color: var(--text-primary);
                background-color: var(--bg-input);
            }
            
            /* Improve contrast for scrollbars */
            ::-webkit-scrollbar {
                width: 8px;
                height: 8px;
            }
            
            ::-webkit-scrollbar-track {
                background: var(--bg-secondary);
            }
            
            ::-webkit-scrollbar-thumb {
                background: var(--border-dark);
                border-radius: 4px;
            }
            
            ::-webkit-scrollbar-thumb:hover {
                background: var(--btn-secondary);
            }
        }

        /* Animation Controls */
        .animation-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
            padding: 10px;
            background-color: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }
        
        #animation-progress {
            flex: 1;
            cursor: pointer;
            accent-color: var(--btn-primary);
        }
        
        #time-display {
            font-family: monospace;
            font-size: 12px;
            min-width: 85px;
            text-align: right;
            color: var(--text-primary);
        }

        .bg-controls {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-left: 10px;
            padding-left: 10px;
            border-left: 1px solid var(--border-color);
        }
        
        .bg-color-picker {
            width: 25px;
            height: 25px;
            padding: 0;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            background: none;
        }
        
        .bg-btn {
            width: 25px;
            height: 25px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            background-color: var(--bg-input);
            color: var(--text-primary);
        }
        
        .bg-btn:hover {
            background-color: var(--border-color);
        }
        
        .bg-btn.active {
            background-color: var(--btn-primary);
            color: white;
            border-color: var(--btn-primary);
        }
    </style>
</head>
<body>
    <div class="lottie-player-container">
        <div class="header-container">
            <div class="title-section">
                <h1 style="margin: 0; font-size: 24px;">Lottie渐变编辑器</h1>
            </div>
            
            <div class="controls-section">
                <div class="file-upload">
                    <label for="lottie-file" class="btn btn-flat-primary header-btn file-input-label">
                        <i class="fa-solid fa-upload"></i> 导入 JSON
                    </label>
                    <input type="file" id="lottie-file" class="file-input" accept=".json">
                    <button id="export-btn" class="btn btn-flat-primary header-btn export-btn" style="margin: 0;">
                        <i class="fa-solid fa-download"></i> 导出 JSON
                    </button>
                    <span id="file-info" class="file-info" style="display: none;">未选择文件</span>
                </div>
                
                <button id="theme-toggle" class="btn btn-flat-primary header-btn">
                    <i class="fa-solid fa-moon"></i> 深色模式
                </button>
            </div>
        </div>
        
        <!-- Combined Preview and Editor Section -->
        <div class="playground-container">
            <!-- Left Side: Lottie Animation Preview -->
            <div class="preview-section">
                <div id="lottie-animation" class="lottie-animation alpha_checkered"></div>
                <div class="animation-controls">
                    <button id="play-pause-btn" class="btn btn-secondary btn-sm" title="播放/暂停" style="width: 32px; height: 32px; padding: 0;">
                        <i class="fa-solid fa-pause"></i>
                    </button>
                    <input type="range" id="animation-progress" min="0" max="100" value="0" step="0.1">
                    <span id="time-display">0 / 0</span>
                    
                    <div class="bg-controls">
                        <input type="color" id="bg-color-picker" class="bg-color-picker" title="背景颜色" value="#ffffff">
                        <button id="bg-alpha-btn" class="bg-btn active" title="透明背景 (Alpha)">
                            <i class="fa-solid fa-border-all"></i>
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Right Side: Editor Section -->
            <div class="editor-section">
                <!-- Gradient List -->
                <div class="gradient-names-section main-gradient-section">
                    <h3>渐变列表</h3>
                    <div class="gradient-search-container">
                        <input type="text" id="gradient-search" placeholder="搜索渐变..." class="gradient-search-input">
                    </div>
                    <div id="gradient-names-list" class="gradient-names-list">
                        <p>未找到渐变。上传 JSON 文件以查看渐变。</p>
                    </div>
                </div>
                
                <!-- Color Editor -->
                <div id="editor-container" class="editor-container">
                    <h3 id="editor-title">未选择渐变</h3>
                    <div id="editor"></div>
                </div>
            </div>
            
            <!-- Hidden elements -->
            <div class="json-editor-section-full" style="display: none;">
                <h3>JSON 编辑器</h3>
                <div class="json-editor-controls">
                    <button id="format-json-btn" class="btn btn-primary btn-sm">
                        <i class="fa-solid fa-code"></i> 格式化 JSON
                    </button>
                    <button id="update-animation-btn" class="btn btn-primary btn-sm">
                        <i class="fa-solid fa-play"></i> 更新动画
                    </button>
                </div>
                
                <div class="json-editor-container">
                    <div id="monaco-editor-container"></div>
                    <!-- Fallback textarea for older browsers -->
                    <textarea id="json-editor" placeholder="上传文件或在此处编辑 JSON..." style="display: none;"></textarea>
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden legacy structure -->
    <div class="playground playground-columns" style="display: none;">
        <!-- Left Side: Adobe Gradients -->
        <div class="gradient-names-section main-gradient-section">
            <h3>渐变列表</h3>
            <div id="gradient-names-list-legacy" class="gradient-names-list">
                <p>未找到渐变。上传 JSON 文件以查看渐变。</p>
            </div>
        </div>
        
        <!-- Middle: Color Editor -->
        <div id="editor-legacy"></div>
        
        <!-- Right Side: Generated JSON -->
        <div class="json-viewer">
            <h3>生成的 JSON</h3>
            <pre><code class="language-json" id="json_viewer"></code></pre>
        </div>
    </div>

    <script>
        // Helper functions
        function truncate_float(num) {
            return Math.round(num * 1000) / 1000;
        }

        function color_lottie_to_hex(lottie) {
            let r = Math.round(lottie[0] * 255).toString(16).padStart(2, '0');
            let g = Math.round(lottie[1] * 255).toString(16).padStart(2, '0');
            let b = Math.round(lottie[2] * 255).toString(16).padStart(2, '0');
            return `#${r}${g}${b}`;
        }

        function color_hex_to_lottie(hex) {
            let r = parseInt(hex.slice(1, 3), 16) / 255;
            let g = parseInt(hex.slice(3, 5), 16) / 255;
            let b = parseInt(hex.slice(5, 7), 16) / 255;
            return [r, g, b];
        }

        function color_lottie_to_hex_component(alpha) {
            let a = Math.round(alpha * 255).toString(16).padStart(2, '0');
            return a;
        }

        // GradientPreviewEditor class
        class GradientPreviewEditor {
            constructor(parent, lottie, color_count, on_change, dynamic_count = false) {
                this.on_change = on_change;
                
                // Calculate the correct color count based on Lottie gradient format
                // For gradients without alpha: [offset, r, g, b, offset, r, g, b, ...]
                // For gradients with alpha: [offset, r, g, b, offset, r, g, b, ..., offset, a, offset, a, ...]
                
                let rgbStopCount;
                this.with_alpha = false;
                
                // Determine if gradient has alpha based on array length and provided color_count
                // Priority 1: Check if length matches expected for given color_count
                // For color_count stops without alpha: expected length = color_count * 4
                // For color_count stops with alpha: expected length = color_count * 6
                if (lottie.length === color_count * 6) {
                    // Exact match for color_count stops with alpha
                    this.with_alpha = true;
                    rgbStopCount = color_count;
                } 
                else if (lottie.length === color_count * 4) {
                    // Exact match for color_count stops without alpha
                    this.with_alpha = false;
                    rgbStopCount = color_count;
                } 
                // Priority 2: Fallback to check divisibility if no exact match
                else {
                    // Always use the provided color_count as a reference first
                    // This fixes the issue where enabling alpha on 4 color stops (length 24) would be incorrectly calculated as 6 stops
                    if (lottie.length === color_count * 4) {
                        // No alpha: length matches provided color_count * 4
                        this.with_alpha = false;
                        rgbStopCount = color_count;
                    } else if (lottie.length === color_count * 6) {
                        // With alpha: length matches provided color_count * 6
                        this.with_alpha = true;
                        rgbStopCount = color_count;
                    } else {
                        // If no match, fall back to original calculation with priority on 4
                        if (lottie.length % 6 === 0) {
                            // Has alpha: each color stop contributes 6 values
                            this.with_alpha = true;
                            color_count = lottie.length / 6;
                            rgbStopCount = color_count;
                        } else if (lottie.length % 4 === 0) {
                            // No alpha: each color stop contributes 4 values
                            this.with_alpha = false;
                            color_count = lottie.length / 4;
                            rgbStopCount = color_count;
                        } else {
                            // Invalid gradient data length
                            console.error('Invalid gradient data length:', lottie.length);
                            // Default to no alpha and calculate color count from length
                            this.with_alpha = false;
                            color_count = Math.floor(lottie.length / 4);
                            rgbStopCount = color_count;
                        }
                    }
                }

                let self = this;
                this.colors = [];
                // Initialize debounce timer
                this.debounceTimer = null;

                // First create preview container and gradient-preview div
                let preview_cont = parent.appendChild(document.createElement("div"));
                preview_cont.classList.add("alpha_checkered");

                this.preview = preview_cont.appendChild(document.createElement("div"));
                this.preview.classList.add("gradient-preview");
                this.preview.setAttribute("style", "background:" + this.to_css());

                // Then create the label with checkbox
                let label = parent.appendChild(document.createElement("p"))
                    .appendChild(document.createElement("label"));
                this.check_alpha = label.appendChild(document.createElement("input"));
                this.check_alpha.type = "checkbox";
                this.check_alpha.checked = this.with_alpha;
                this.check_alpha.addEventListener("input", () => {
                    self.with_alpha = self.check_alpha.checked;
                    for (let color of self.colors) {
                        color.alpha_input.disabled = !self.with_alpha;
                        color.alpha_label.style.opacity = self.with_alpha ? "1" : "0.6";
                        // Also update opacity of percentage sign
                        if (color.alpha_percent) {
                            color.alpha_percent.style.opacity = self.with_alpha ? "1" : "0.6";
                        }
                    }
                    self._on_change();
                });
                label.appendChild(document.createTextNode(" 启用透明度"));

                this.parent = parent.appendChild(document.createElement("div"));
                
                // Only process gradient data if we have some
                if (lottie && lottie.length > 0) {
                    for (let i = 0; i < color_count; i++) {
                        // Parse RGB values
                        const offset = lottie[i * 4];
                        const rgb = lottie.slice(i * 4 + 1, i * 4 + 4);
                        
                        // Parse alpha value if available
                        let alpha = 1;
                        if (this.with_alpha) {
                            // Alpha data starts after RGB data, each alpha stop has 2 values (offset, alpha)
                            const alphaOffsetIndex = color_count * 4 + i * 2;
                            alpha = lottie[alphaOffsetIndex + 1]; // alpha value is the second in the pair
                        }
                        
                        this.add_color(
                            offset,
                            color_lottie_to_hex(rgb),
                            alpha,
                            dynamic_count
                        );
                    }
                }

                if (dynamic_count) {
                    let btn = parent.appendChild(document.createElement("button"));
                    btn.setAttribute("class", "btn btn-success btn-sm btn-delete");
                    btn.title = "添加色标";
                    btn.innerHTML = "<i class='fa-solid fa-plus'></i> 添加色标";
                    btn.addEventListener("click", () => {
                        self.add_color(1, "#000000", 1, true);
                        self._on_change();
                    });
                }
            }

            add_color(offset, hex, alpha, dynamic_count) {
                let self = this;
                let color = {
                    offset: offset,
                    color: hex,
                    alpha: alpha,
                };
                this.colors.push(color);

                let p = this.parent.appendChild(document.createElement("p"));
                p.classList.add("gradient-editor");
                
                // First row: Color block and Delete button
                let row1 = p.appendChild(document.createElement("div"));
                row1.classList.add("gradient-editor-row");
                
                // Color block
                let in_col = row1.appendChild(document.createElement("input"));
                in_col.type = "color";
                in_col.value = color.color;
                in_col.addEventListener("input", () => {
                    color.color = in_col.value;
                    // Debounce _on_change to improve performance during color selection
                    if (self.debounceTimer) {
                        clearTimeout(self.debounceTimer);
                    }
                    self.debounceTimer = setTimeout(() => {
                        self._on_change();
                    }, 100);
                });
                
                // Delete button
                if (dynamic_count) {
                    let btn = row1.appendChild(document.createElement("button"));
                    btn.setAttribute("class", "btn btn-danger btn-sm btn-delete");
                    btn.title = "删除色标";
                    btn.innerHTML = "<i class='fa-solid fa-trash'></i>";
                    btn.style.width = "auto";
                    btn.addEventListener("click", () => {
                        self.parent.removeChild(p);
                        self.colors.splice(self.colors.indexOf(color), 1);
                        self._on_change();
                    });
                }
                
                // Second row: Position and Alpha
                let row2 = p.appendChild(document.createElement("div"));
                row2.classList.add("gradient-editor-row");
                
                // Position label and input
                let posLabel = row2.appendChild(document.createElement("label"));
                posLabel.classList.add("gradient-editor-label");
                posLabel.textContent = "位置:";
                let in_off = row2.appendChild(document.createElement("input"));
                in_off.title = "Offset";
                in_off.type = "number";
                in_off.min = 0;
                in_off.max = 100;
                in_off.step = 1;
                in_off.value = color.offset * 100;
                in_off.addEventListener("input", () => {
                    let value = Number(in_off.value);
                    // Ensure value is between 0 and 100
                    if (isNaN(value) || value < 0) {
                        value = 0;
                        in_off.value = value;
                    } else if (value > 100) {
                        value = 100;
                        in_off.value = value;
                    }
                    // Convert percentage to decimal for internal storage
                    color.offset = value / 100;
                    // Debounce _on_change to improve performance during drag
                    if (self.debounceTimer) {
                        clearTimeout(self.debounceTimer);
                    }
                    self.debounceTimer = setTimeout(() => {
                        self._on_change();
                    }, 100);
                });
                // Add percentage sign after position input
                let posPercent = row2.appendChild(document.createElement("span"));
                posPercent.classList.add("gradient-editor-label");
                posPercent.textContent = "%";
                
                // Alpha label and input
                let alphaLabel = row2.appendChild(document.createElement("label"));
                alphaLabel.classList.add("gradient-editor-label");
                alphaLabel.textContent = "透明度:";
                let in_alpha = row2.appendChild(document.createElement("input"));
                in_alpha.title = "Alpha";
                in_alpha.type = "number";
                in_alpha.min = 0;
                in_alpha.max = 100;
                in_alpha.step = 1;
                in_alpha.value = color.alpha * 100;
                in_alpha.disabled = !this.with_alpha;
                alphaLabel.style.opacity = this.with_alpha ? "1" : "0.6";
                in_alpha.addEventListener("input", () => {
                    let value = Number(in_alpha.value);
                    // Ensure value is between 0 and 100
                    if (isNaN(value) || value < 0) {
                        value = 0;
                        in_alpha.value = value;
                    } else if (value > 100) {
                        value = 100;
                        in_alpha.value = value;
                    }
                    // Convert percentage to decimal for internal storage
                    color.alpha = value / 100;
                    // Debounce _on_change to improve performance during alpha adjustment
                    if (self.debounceTimer) {
                        clearTimeout(self.debounceTimer);
                    }
                    self.debounceTimer = setTimeout(() => {
                        self._on_change();
                    }, 100);
                });
                // Add percentage sign after alpha input
                let alphaPercent = row2.appendChild(document.createElement("span"));
                alphaPercent.classList.add("gradient-editor-label");
                alphaPercent.textContent = "%";
                alphaPercent.style.opacity = this.with_alpha ? "1" : "0.6";
                color.alpha_input = in_alpha;
                color.alpha_label = alphaLabel;
                color.alpha_percent = alphaPercent;
            }

            to_css() {
                let items = [];
                for (let color of this.colors) {
                    let stop = color.color;
                    if (this.with_alpha) {
                        stop += color_lottie_to_hex_component(color.alpha);
                    }
                    stop += " " + (color.offset * 100) + "%";
                    items.push(stop);
                }
                // Return transparent if no colors
                if (items.length === 0) {
                    return "transparent";
                }
                return "linear-gradient(90deg, " + items.join(",") + ")";
            }

            _on_change() {
                let lottie = [];
                let alpha = [];
                for (let color of this.colors) {
                    lottie.push(color.offset, ...color_hex_to_lottie(color.color));
                    if (this.with_alpha) {
                        alpha.push(color.offset, color.alpha);
                    }
                }

                this.preview.setAttribute("style", "background:" + this.to_css());
                this.on_change(lottie.concat(alpha));
            }

            // Method to update the gradient with new data
            update(lottie, color_count) {
                // Clear existing colors and UI
                this.parent.innerHTML = '';
                this.colors = [];
                
                // If no gradient data is provided, just clear the editor
                if (!lottie || lottie.length === 0) {
                    this.preview.setAttribute("style", "background: transparent");
                    return;
                }
                
                // Calculate the correct color count based on Lottie gradient format
                // For gradients without alpha: [offset, r, g, b, offset, r, g, b, ...]
                // For gradients with alpha: [offset, r, g, b, offset, r, g, b, ..., offset, a, offset, a, ...]
                
                let rgbStopCount;
                this.with_alpha = false;
                
                // Determine if gradient has alpha based on array length and provided color_count
                // Priority 1: Check if length matches expected for given color_count
                // For color_count stops without alpha: expected length = color_count * 4
                // For color_count stops with alpha: expected length = color_count * 6
                if (lottie.length === color_count * 6) {
                    // Exact match for color_count stops with alpha
                    this.with_alpha = true;
                    rgbStopCount = color_count;
                } 
                else if (lottie.length === color_count * 4) {
                    // Exact match for color_count stops without alpha
                    this.with_alpha = false;
                    rgbStopCount = color_count;
                } 
                // Priority 2: Fallback to check divisibility if no exact match
                // Always calculate based on the provided color_count first
                else {
                    // Use the provided color_count as reference
                    // This fixes the issue where enabling alpha on 4 color stops (length 24) would be incorrectly calculated as 6 stops
                    if (lottie.length === color_count * 4) {
                        // No alpha: length matches provided color_count * 4
                        this.with_alpha = false;
                        rgbStopCount = color_count;
                    } else if (lottie.length === color_count * 6) {
                        // With alpha: length matches provided color_count * 6
                        this.with_alpha = true;
                        rgbStopCount = color_count;
                    } else {
                        // If no match, fall back to original calculation with priority on 4
                        if (lottie.length % 6 === 0) {
                            // Has alpha: each color stop contributes 6 values
                            this.with_alpha = true;
                            color_count = lottie.length / 6;
                            rgbStopCount = color_count;
                        } else if (lottie.length % 4 === 0) {
                            // No alpha: each color stop contributes 4 values
                            this.with_alpha = false;
                            color_count = lottie.length / 4;
                            rgbStopCount = color_count;
                        } else {
                            // Invalid gradient data length
                            console.error('Invalid gradient data length:', lottie.length);
                            // Default to no alpha and calculate color count from length
                            this.with_alpha = false;
                            color_count = Math.floor(lottie.length / 4);
                            rgbStopCount = color_count;
                        }
                    }
                }
                
                // Recreate color inputs
                for (let i = 0; i < color_count; i++) {
                    // Parse RGB values
                    const offset = lottie[i * 4];
                    const rgb = lottie.slice(i * 4 + 1, i * 4 + 4);
                    
                    // Parse alpha value if available
                    let alpha = 1;
                    if (this.with_alpha) {
                        // Alpha data starts after RGB data, each alpha stop has 2 values (offset, alpha)
                        const alphaOffsetIndex = color_count * 4 + i * 2;
                        alpha = lottie[alphaOffsetIndex + 1]; // alpha value is the second in the pair
                    }
                    
                    this.add_color(
                        offset,
                        color_lottie_to_hex(rgb),
                        alpha,
                        true // dynamic_count
                    );
                }
                
                // Update the preview directly without calling _on_change()
                // This prevents animation restart when just selecting a gradient from the list
                this.preview.setAttribute("style", "background:" + this.to_css());
                
                // Update the checkbox state to match with_alpha property
                if (this.check_alpha) {
                    this.check_alpha.checked = this.with_alpha;
                }
            }
            
            static stand_alone(parent, on_change) {
                // Initialize with empty gradient
                let initial = [];
                return new GradientPreviewEditor(parent, initial, 0, on_change, true);
            }
            
            // Method to clear the gradient editor
            clear() {
                // Clear existing colors and UI
                this.parent.innerHTML = '';
                this.colors = [];
                this.preview.setAttribute("style", "background: transparent");
            }
        }

        // Initialize the editor when the page loads
        let gradientEditorInstance = null;
        let selectedGradientInfo = null; // Store information about the currently selected gradient
        let monacoEditor = null; // Global reference to Monaco Editor
        let animation = null; // Global reference to Lottie animation
        let isProgrammaticUpdate = false; // Flag to prevent duplicate animation updates
        
        document.addEventListener('DOMContentLoaded', () => {
            // Theme Toggle Logic
            const themeToggle = document.getElementById('theme-toggle');
            const body = document.body;
            
            // Drag and Drop JSON Import Functionality
            const setupDragAndDrop = () => {
                const container = document.querySelector('.lottie-player-container');
                
                // Prevent default drag behaviors
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    container.addEventListener(eventName, preventDefaults, false);
                    document.body.addEventListener(eventName, preventDefaults, false);
                });
                
                function preventDefaults(e) {
                    e.preventDefault();
                    e.stopPropagation();
                }
                
                // Add drag over event listener to show drop zone
                ['dragenter', 'dragover'].forEach(eventName => {
                    container.addEventListener(eventName, highlight, false);
                });
                
                // Add drag leave event listener to hide drop zone
                ['dragleave', 'drop'].forEach(eventName => {
                    container.addEventListener(eventName, unhighlight, false);
                });
                
                function highlight() {
                    container.classList.add('drag-over');
                }
                
                function unhighlight() {
                    container.classList.remove('drag-over');
                }
                
                // Add drop event listener to handle file drop
                container.addEventListener('drop', handleDrop, false);
                
                function handleDrop(e) {
                    const files = Array.from(e.dataTransfer.files);
                    const jsonFile = files.find(file => file.type === 'application/json' || file.name.endsWith('.json'));
                    
                    if (jsonFile) {
                        // Read the file content
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            try {
                                const jsonData = JSON.parse(event.target.result);
                                loadAnimation(jsonData);
                                
                                // Update file info display
                                const fileInfo = document.getElementById('file-info');
                                fileInfo.textContent = `已导入: ${jsonFile.name}`;
                                fileInfo.style.display = 'inline-block';
                            } catch (error) {
                                alert('无效的 JSON 文件: ' + error.message);
                            }
                        };
                        reader.onerror = () => {
                            alert('读取文件失败');
                        };
                        reader.readAsText(jsonFile);
                    } else {
                        alert('请拖拽有效的 JSON 文件');
                    }
                }
            };
            
            // Setup drag and drop functionality
            setupDragAndDrop();
            
            // Check for saved theme in localStorage or use system preference
            const savedTheme = localStorage.getItem('theme');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            
            // Set initial theme
            const initialTheme = savedTheme || (prefersDark ? 'dark' : 'light');
            body.setAttribute('data-theme', initialTheme);
            
            // Update button text and icon based on current theme
            const updateThemeButton = () => {
                const currentTheme = body.getAttribute('data-theme');
                if (currentTheme === 'dark') {
                    themeToggle.innerHTML = '<i class="fa-solid fa-sun"></i> 浅色模式';
                } else {
                    themeToggle.innerHTML = '<i class="fa-solid fa-moon"></i> 深色模式';
                }
            };
            
            // Call once to set initial button state
            updateThemeButton();
            
            // Add click event listener for theme toggle
            themeToggle.addEventListener('click', () => {
                const currentTheme = body.getAttribute('data-theme');
                const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                
                // Update theme attribute on body
                body.setAttribute('data-theme', newTheme);
                
                // Save theme preference to localStorage
                localStorage.setItem('theme', newTheme);
                
                // Update button text and icon
                updateThemeButton();
            });
            
            // Initialize Gradient Editor
            gradientEditorInstance = GradientPreviewEditor.stand_alone(document.getElementById("editor"), (lottie) => {
                var raw_json = JSON.stringify(lottie, undefined, 4);
                document.getElementById("json_viewer").innerHTML = raw_json;
                
                // If a gradient is selected, update it in the JSON editor
                if (selectedGradientInfo) {
                    updateGradientInJson(lottie);
                }
            });

            // Initialize Lottie Player
            initializeLottiePlayer();
        });
        
        // Function to update the selected gradient in the JSON editor
        function updateGradientInJson(newGradientData) {
            // Get current JSON content from Monaco Editor
            if (monacoEditor) {
                try {
                    const jsonContent = monacoEditor.getValue();
                    const jsonData = JSON.parse(jsonContent);
                    
                    // Find and update the gradient in the JSON data
                    // Pass the actual color count from the editor instead of calculating it from the array
                    updateGradientInJsonData(jsonData, selectedGradientInfo, newGradientData, gradientEditorInstance.colors.length);
                    
                    // Update the Monaco Editor with the modified JSON
                    const updatedJsonContent = JSON.stringify(jsonData, null, 2);
                    
                    // Check if content has actually changed before updating
                    if (updatedJsonContent !== jsonContent) {
                        isProgrammaticUpdate = true;
                        monacoEditor.setValue(updatedJsonContent);
                        
                        // Auto-update the animation preview only when content actually changes
                        // This allows users to see the updated gradient immediately
                        updateAnimationFromEditor();
                    }
                    // If content hasn't changed, it means we're just selecting a gradient, not modifying it
                    // So we don't need to update the animation
                } catch (error) {
                    console.error('Error updating gradient in JSON:', error);
                }
            }
        }
        
        // Recursive function to find and update the gradient in JSON data
        function updateGradientInJsonData(jsonData, gradientInfo, newGradientData, colorCount) {
            let updated = false;
            // Check if this is the object containing the gradient
            if (typeof jsonData === 'object' && jsonData !== null) {
                // If it's the gradient object, update its "k" property
                if (jsonData.ty === 'gf' && jsonData.nm === gradientInfo.name) {
                    if (jsonData.g) {
                        // Update the gradient data
                        if (jsonData.g.k && typeof jsonData.g.k === 'object' && 'k' in jsonData.g.k) {
                            // Handle nested k structure: g.k is an object with a k property
                            jsonData.g.k.k = newGradientData;
                            // Update the color count (p property) in the gradient using the actual editor color count
                            if (jsonData.g.p !== undefined) {
                                jsonData.g.p = colorCount;
                            }
                        } else {
                            // Handle direct k structure: g.k is the array directly
                            jsonData.g.k = newGradientData;
                            // Update the color count (p property) in the gradient using the actual editor color count
                            if (jsonData.g.p !== undefined) {
                                jsonData.g.p = colorCount;
                            }
                        }
                        updated = true;
                    }
                }
                
                // Recursively check all properties
                        for (const key in jsonData) {
                            if (jsonData.hasOwnProperty(key)) {
                                const value = jsonData[key];
                                if (typeof value === 'object' && value !== null) {
                                    if (updateGradientInJsonData(value, gradientInfo, newGradientData, colorCount)) {
                                        updated = true;
                                    }
                                }
                            }
                        }
                    } else if (Array.isArray(jsonData)) {
                        // Check each item in the array
                        for (const item of jsonData) {
                            if (updateGradientInJsonData(item, gradientInfo, newGradientData, colorCount)) {
                                updated = true;
                            }
                        }
                    }
            return updated;
        }

        // Lottie Player and JSON Editor functions
        function initializeLottiePlayer() {
            let debounceTimer = null;
            const fileInput = document.getElementById('lottie-file');
            const fileInfo = document.getElementById('file-info');
            const animationContainer = document.getElementById('lottie-animation');
            const jsonEditor = document.getElementById('json-editor');
            const formatJsonBtn = document.getElementById('format-json-btn');
            const updateAnimationBtn = document.getElementById('update-animation-btn');
            
            // Animation controls
            const playPauseBtn = document.getElementById('play-pause-btn');
            const progressBar = document.getElementById('animation-progress');
            const timeDisplay = document.getElementById('time-display');
            const playIcon = '<i class="fa-solid fa-play"></i>';
            const pauseIcon = '<i class="fa-solid fa-pause"></i>';
            let isDragging = false;
            
            // Background controls
            const bgColorPicker = document.getElementById('bg-color-picker');
            const bgAlphaBtn = document.getElementById('bg-alpha-btn');
            
            // Editor title
            const editorTitle = document.getElementById('editor-title');
            
            // Initialize Monaco Editor
            function initMonacoEditor() {
                require.config({
                    paths: {
                        'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.41.0/min/vs'
                    }
                });

                require(['vs/editor/editor.main'], function() {
                    // Ensure the container has proper dimensions before initializing
                    const container = document.getElementById('monaco-editor-container');
                    
                    // Force the container to have the correct height
                    container.style.display = 'block';
                    container.style.width = '100%';
                    container.style.height = '400px';
                    
                    monacoEditor = monaco.editor.create(container, {
                        value: '',
                        language: 'json',
                        theme: 'vs',
                        automaticLayout: true,
                        minimap: {
                            enabled: true
                        },
                        scrollBeyondLastLine: false,
                        wordWrap: 'on',
                        formatOnPaste: true,
                        formatOnType: true,
                        tabSize: 2,
                        lineNumbers: 'on',
                        glyphMargin: true,
                        folding: true,
                        scrollbar: {
                            vertical: 'visible',
                            horizontal: 'visible',
                            useShadows: false
                        }
                    });

                    // Add JSON validation
                    monaco.languages.json.jsonDefaults.setDiagnosticsOptions({
                        validate: true,
                        schemas: []
                    });
                    
                    // Update editor when window is resized
                    window.addEventListener('resize', function() {
                        monacoEditor.layout();
                    });
                    
                    // Add change listener for auto-update functionality
                    monacoEditor.onDidChangeModelContent(function() {
                        // Auto-update animation when editor content changes
                        // Use debounce to avoid excessive updates
                        if (debounceTimer) {
                            clearTimeout(debounceTimer);
                        }
                        debounceTimer = setTimeout(function() {
                            if (!isProgrammaticUpdate) {
                                updateAnimationFromEditor();
                            }
                            // Update gradient names list when editor content changes
                            updateGradientNamesList();
                            // Reset the flag for next change
                            isProgrammaticUpdate = false;
                        }, 500); // 500ms debounce
                    });
                });
            }
            
            // Initialize Monaco Editor when DOM is ready and container is properly sized
            if (typeof require !== 'undefined') {
                // Use setTimeout to ensure DOM is fully rendered
                setTimeout(initMonacoEditor, 100);
            } else {
                // Fallback if require is not available (older browsers)
                document.getElementById('json-editor').style.display = 'block';
                document.getElementById('monaco-editor-container').style.display = 'none';
            }
            
            // Initialize gradient search functionality
            const gradientSearch = document.getElementById('gradient-search');
            if (gradientSearch) {
                gradientSearch.addEventListener('input', function() {
                    const searchTerm = gradientSearch.value.toLowerCase().trim();
                    const gradientItems = document.querySelectorAll('.gradient-name-item');
                    
                    let visibleItems = 0;
                    gradientItems.forEach(item => {
                        const gradientName = item.querySelector('.gradient-name').textContent.toLowerCase();
                        if (gradientName.includes(searchTerm)) {
                            item.style.display = 'block';
                            visibleItems++;
                        } else {
                            item.style.display = 'none';
                        }
                    });
                    
                    // Check if any gradient items are visible
                    const noResultsMsg = document.getElementById('no-results-msg');
                    if (visibleItems === 0) {
                        // Create no results message if it doesn't exist
                        if (!noResultsMsg) {
                            const gradientNamesList = document.getElementById('gradient-names-list');
                            const msg = document.createElement('div');
                            msg.id = 'no-results-msg';
                            msg.textContent = '未找到匹配的渐变。';
                            msg.style.textAlign = 'center';
                            msg.style.padding = '20px';
                            msg.style.color = 'var(--text-secondary)';
                            gradientNamesList.appendChild(msg);
                        } else {
                            noResultsMsg.style.display = 'block';
                        }
                    } else {
                        // Hide no results message if it exists
                        if (noResultsMsg) {
                            noResultsMsg.style.display = 'none';
                        }
                    }
                });
            }
            
            // Add a check to ensure editor content is properly synced
            function ensureContentSynced() {
                if (monacoEditor && jsonEditor.value !== monacoEditor.getValue()) {
                    console.log('Syncing textarea with Monaco Editor content');
                    jsonEditor.value = monacoEditor.getValue();
                }
            }
            
            // Sync content every second for safety
            setInterval(ensureContentSynced, 1000);

            // Function to load and play Lottie animation
            function loadAnimation(jsonData) {
                try {
                    console.log('Loading animation with data:', JSON.stringify(jsonData).substring(0, 100) + '...');
                    
                    // Destroy existing animation if any
                    if (animation) {
                        console.log('Destroying existing animation');
                        animation.destroy();
                        animation = null;
                    }

                    // Reset controls
                    if (playPauseBtn) playPauseBtn.innerHTML = pauseIcon;
                    if (progressBar) progressBar.value = 0;

                    // Load new animation
                    console.log('Creating new animation with bodymovin');
                    animation = bodymovin.loadAnimation({
                        container: animationContainer,
                        renderer: 'svg',
                        loop: true,
                        autoplay: true,
                        animationData: jsonData
                    });
                    console.log('Animation created successfully');
                    
                    // Add animation event listeners for debugging
                    animation.addEventListener('DOMLoaded', () => {
                        console.log('Animation DOMLoaded event fired');
                        updateTimeDisplay();
                    });
                    
                    animation.addEventListener('enterFrame', () => {
                        if (!isDragging && animation && progressBar) {
                            const progress = (animation.currentFrame / animation.totalFrames) * 100;
                            progressBar.value = progress;
                            updateTimeDisplay();
                        }
                    });
                    
                    animation.addEventListener('loopComplete', () => {
                        console.log('Animation loopComplete event fired');
                    });
                    
                    animation.addEventListener('complete', () => {
                        console.log('Animation complete event fired');
                        if (playPauseBtn) playPauseBtn.innerHTML = playIcon;
                    });
                    
                    animation.addEventListener('error', (error) => {
                        console.error('Animation error event fired:', error);
                    });
                    
                } catch (error) {
                    console.error('Error loading animation:', error);
                    alert('Error loading animation: ' + error.message);
                }
            }

            // Function to update JSON editor content
            function updateJsonEditor(jsonData) {
                const jsonString = JSON.stringify(jsonData, undefined, 2);
                console.log('Updating JSON editor with content:', jsonString.substring(0, 100) + (jsonString.length > 100 ? '...' : ''));
                
                if (monacoEditor) {
                    monacoEditor.setValue(jsonString);
                    console.log('Monaco Editor content updated successfully');
                }
                jsonEditor.value = jsonString;
            }

            // Function to get JSON content from editor
            function getJsonContent() {
                let content = '';
                
                // Check if Monaco Editor is available and has content
                if (monacoEditor) {
                    try {
                        content = monacoEditor.getValue();
                        console.log('Got content from Monaco Editor, length:', content.length);
                    } catch (e) {
                        console.error('Error getting content from Monaco Editor:', e.message);
                        // Fallback to textarea
                        content = jsonEditor.value;
                    }
                } else {
                    content = jsonEditor.value;
                }
                
                // Ensure we have valid content
                if (!content.trim()) {
                    console.log('Content is empty, returning empty string');
                }
                
                return content;
            }
            
            // Function to format JSON in editor
            function formatJson() {
                const jsonText = getJsonContent();
                if (jsonText.trim() === '') {
                    return;
                }

                try {
                    const jsonData = JSON.parse(jsonText);
                    updateJsonEditor(jsonData);
                    
                    // If Monaco Editor is available, use its format command
                    if (monacoEditor) {
                        monacoEditor.getAction('editor.action.formatDocument').run();
                    }
                } catch (error) {
                    console.error('Error formatting JSON:', error);
                    alert('Invalid JSON format. Please check your JSON and try again.');
                }
            }

            // Function to find all Adobe gradient names in JSON
            function findAdobeGradientNames(jsonData) {
                const gradients = [];
                const foundNames = new Set(); // Use Set to track unique gradient names
                
                // Recursive function to traverse JSON and find gradients with their "g" data
                function traverse(obj, parent = null, path = []) {
                    if (obj === null || typeof obj !== 'object') {
                        return;
                    }
                    
                    // Check if this is a gradient fill object
                    if (obj.ty === 'gf' && obj.mn === 'ADBE Vector Graphic - G-Fill' && obj.nm) {
                        const name = obj.nm;
                        // Only add each gradient name once, regardless of how many times it appears
                        if (!foundNames.has(name)) {
                            foundNames.add(name);
                            gradients.push({
                                name: name,
                                gradientData: obj.g || {}, // Store the "g" tag content
                                parent: parent,
                                path: path.join('.') // Store the path for debugging
                            });
                        }
                    }
                    
                    // If this object has a shapes array, check its items
                    if (obj.shapes && Array.isArray(obj.shapes)) {
                        for (const shape of obj.shapes) {
                            traverse(shape, obj, [...path, 'shapes']);
                        }
                    }
                    
                    // If this is an array, check all items
                    if (Array.isArray(obj)) {
                        for (let i = 0; i < obj.length; i++) {
                            traverse(obj[i], obj, [...path, i]);
                        }
                    }
                    
                    // If this is an object, check all properties
                    else if (typeof obj === 'object') {
                        for (const key in obj) {
                            traverse(obj[key], obj, [...path, key]);
                        }
                    }
                }
                
                // Start traversal
                traverse(jsonData);
                
                return gradients;
            }
            
            // Function to update gradient names list
            function updateGradientNamesList() {
                const gradientNamesList = document.getElementById('gradient-names-list');
                
                // Reset search input and remove any no results message
                const gradientSearch = document.getElementById('gradient-search');
                if (gradientSearch) {
                    gradientSearch.value = '';
                }
                const noResultsMsg = document.getElementById('no-results-msg');
                if (noResultsMsg) {
                    noResultsMsg.remove();
                }
                
                try {
                    // First try to use animationData (already parsed JSON from animation)
                    if (animation && animation.animationData) {
                        console.log('Using animationData for gradient names');
                        const gradients = findAdobeGradientNames(animation.animationData);
                        
                        if (gradients.length === 0) {
                            gradientNamesList.innerHTML = '<p>JSON 文件中未找到渐变。</p>';
                            // Clear selected gradient if no gradients found
                            clearSelectedGradient();
                        } else {
                            // Clear existing content
                            gradientNamesList.innerHTML = '';
                            
                            // Create and add gradient items
                            gradients.forEach((gradient, index) => {
                                // Create main gradient item
                                const gradientItem = document.createElement('div');
                                gradientItem.className = 'gradient-name-item';
                                
                                // Check if this gradient is currently selected
                                if (selectedGradientInfo && selectedGradientInfo.name === gradient.name) {
                                    gradientItem.classList.add('selected');
                                }
                                
                                gradientItem.innerHTML = `
                                    <div class="gradient-item-header">
                                        <span class="gradient-name">${gradient.name}</span>
                                    </div>
                                `;
                                
                                // Add click event for navigation
                                const gradientHeader = gradientItem.querySelector('.gradient-item-header');
                                gradientHeader.addEventListener('click', function() {
                                    const gradientName = gradient.name;
                                    console.log('Clicked gradient:', gradientName);
                                    
                                    // Store information about the selected gradient
                                    selectedGradientInfo = {
                                        name: gradient.name,
                                        gradientData: gradient.gradientData
                                    };
                                    
                                    // Update Editor Title
                                    if (editorTitle) {
                                        editorTitle.textContent = gradient.name;
                                    }
                                    
                                    // Remove selected class from all gradient items
                                    const allGradientItems = document.querySelectorAll('.gradient-name-item');
                                    allGradientItems.forEach(item => {
                                        item.classList.remove('selected');
                                    });
                                    
                                    // Add selected class to the clicked gradient item
                                    gradientItem.classList.add('selected');
                                    
                                    // Update Gradient Editor with the clicked gradient's data
                                    if (gradientEditorInstance && gradient.gradientData && gradient.gradientData.k) {
                                        console.log('Updating Gradient Editor with:', gradient.gradientData);
                                        const gradientData = gradient.gradientData;
                                        
                                        // Handle both direct array format and nested object format for k
                                        let gradientK = gradientData.k;
                                        if (typeof gradientK === 'object' && gradientK !== null && gradientK.k) {
                                            // Nested format: k.k contains the actual color stops
                                            gradientK = gradientK.k;
                                        }
                                        
                                        // Calculate color stop count
                                        const colorCount = gradientData.p || Math.floor(gradientK.length / 4);
                                        gradientEditorInstance.update(gradientK, colorCount);
                                    }
                                    
                                    if (monacoEditor) {
                                        console.log('Using Monaco Editor for navigation');
                                        
                                        // Get editor content
                                        const content = monacoEditor.getValue();
                                        
                                        // Find the gradient in the content
                                        const searchText = `"nm":"${gradientName}"`;
                                        const index = content.indexOf(searchText);
                                        
                                        if (index !== -1) {
                                            console.log('Found gradient at index:', index);
                                            
                                            // Calculate line and column
                                            const lines = content.substring(0, index).split('\n');
                                            const line = lines.length - 1;
                                            const column = lines[line].length;
                                            
                                            console.log('Line:', line, 'Column:', column);
                                            
                                            // Set selection and reveal
                                            monacoEditor.setPosition({ lineNumber: line + 1, column: column + 1 });
                                            monacoEditor.revealPositionInCenter({ lineNumber: line + 1, column: column + 1 });
                                            monacoEditor.focus();
                                            
                                            console.log('Navigation completed');
                                        } else {
                                            console.log('Gradient not found in content');
                                        }
                                    } else {
                                        console.log('Monaco Editor not available');
                                    }
                                });
                                
                                // Add hover effect
                                gradientItem.style.cursor = 'pointer';
                                gradientItem.style.transition = 'background-color 0.2s';
                                gradientItem.addEventListener('mouseenter', () => {
                                    gradientItem.style.backgroundColor = '#f0f0f0';
                                });
                                gradientItem.addEventListener('mouseleave', () => {
                                    gradientItem.style.backgroundColor = 'transparent';
                                });
                                
                                // Add to list
                                gradientNamesList.appendChild(gradientItem);
                            });
                        }
                        return;
                    }
                    
                    // If no animationData, try to get from editor
                    const jsonText = getJsonContent();
                    if (jsonText.trim() === '') {
                        gradientNamesList.innerHTML = '<p>未找到渐变。上传 JSON 文件以查看渐变。</p>';
                        return;
                    }
                    
                    // Try to parse JSON from editor content
                    const jsonData = JSON.parse(jsonText);
                    const gradients = findAdobeGradientNames(jsonData);
                    
                    if (gradients.length === 0) {
                        gradientNamesList.innerHTML = '<p>JSON 文件中未找到渐变。</p>';
                    } else {
                        // Clear existing content
                        gradientNamesList.innerHTML = '';
                        
                        // Create and add gradient items with expand/collapse functionality
                        gradients.forEach((gradient, index) => {
                            // Create main gradient item
                            const gradientItem = document.createElement('div');
                            gradientItem.className = 'gradient-name-item';
                            
                            // Check if this gradient is currently selected
                            if (selectedGradientInfo && selectedGradientInfo.name === gradient.name) {
                                gradientItem.classList.add('selected');
                            }
                            
                            gradientItem.innerHTML = `
                                <div class="gradient-item-header">
                                    <span class="gradient-name-index">${index + 1}.</span>
                                    <span class="gradient-name">${gradient.name}</span>
                                </div>
                            `;
                            
                            // Add click event for navigation
                            const gradientNameElement = gradientItem.querySelector('.gradient-name');
                            gradientNameElement.addEventListener('click', function() {
                                const gradientName = gradient.name;
                                console.log('Clicked gradient:', gradientName);
                                
                                // Store information about the selected gradient
                                selectedGradientInfo = {
                                    name: gradient.name,
                                    gradientData: gradient.gradientData
                                };
                                
                                // Update Editor Title
                                if (editorTitle) {
                                    editorTitle.textContent = gradient.name;
                                }
                                
                                // Remove selected class from all gradient items
                                const allGradientItems = document.querySelectorAll('.gradient-name-item');
                                allGradientItems.forEach(item => {
                                    item.classList.remove('selected');
                                });
                                
                                // Add selected class to the clicked gradient item
                                gradientItem.classList.add('selected');
                                
                                // Update Gradient Editor with the clicked gradient's data
                                if (gradientEditorInstance && gradient.gradientData && gradient.gradientData.k) {
                                    console.log('Updating Gradient Editor with:', gradient.gradientData);
                                    const gradientData = gradient.gradientData;
                                    
                                    // Handle both direct array format and nested object format for k
                                    let gradientK = gradientData.k;
                                    if (typeof gradientK === 'object' && gradientK !== null && gradientK.k) {
                                        // Nested format: k.k contains the actual color stops
                                        gradientK = gradientK.k;
                                    }
                                    
                                    // Calculate color stop count
                                    const colorCount = gradientData.p || Math.floor(gradientK.length / 4);
                                    gradientEditorInstance.update(gradientK, colorCount);
                                }
                                
                                if (monacoEditor) {
                                    console.log('Using Monaco Editor for navigation');
                                    
                                    // Get editor content
                                    const content = monacoEditor.getValue();
                                    
                                    // Find the gradient in the content
                                    const searchText = `"nm":"${gradientName}"`;
                                    const index = content.indexOf(searchText);
                                    
                                    if (index !== -1) {
                                        console.log('Found gradient at index:', index);
                                        
                                        // Calculate line and column
                                        const lines = content.substring(0, index).split('\n');
                                        const line = lines.length - 1;
                                        const column = lines[line].length;
                                        
                                        console.log('Line:', line, 'Column:', column);
                                        
                                        // Set selection and reveal
                                        monacoEditor.setPosition({ lineNumber: line + 1, column: column + 1 });
                                        monacoEditor.revealPositionInCenter({ lineNumber: line + 1, column: column + 1 });
                                        monacoEditor.focus();
                                        
                                        console.log('Navigation completed');
                                    } else {
                                        console.log('Gradient not found in content');
                                    }
                                } else {
                                    console.log('Monaco Editor not available');
                                }
                            });
                            
                            // Add hover effect
                            gradientItem.style.cursor = 'pointer';
                            gradientItem.style.transition = 'background-color 0.2s';
                            gradientItem.addEventListener('mouseenter', () => {
                                gradientItem.style.backgroundColor = '#f0f0f0';
                            });
                            gradientItem.addEventListener('mouseleave', () => {
                                gradientItem.style.backgroundColor = 'transparent';
                            });
                            
                            // Add to list
                            gradientNamesList.appendChild(gradientItem);
                        });
                    }
                } catch (error) {
                    console.error('updateGradientNamesList 错误:', error.message);
                    // 显示友好的错误信息，而不是无效的 JSON
                    gradientNamesList.innerHTML = '<p>JSON 文件中未找到渐变。</p>';
                    // Clear selected gradient if there's an error
                    clearSelectedGradient();
                }
            }
            
            // Function to update animation from JSON editor
            function updateAnimationFromEditor() {
                const jsonText = getJsonContent();
                if (jsonText.trim() === '') {
                    alert('请先输入或上传 JSON 文件。');
                    return;
                }

                try {
                    console.log('Attempting to parse JSON:', jsonText.substring(0, 100) + (jsonText.length > 100 ? '...' : ''));
                    const jsonData = JSON.parse(jsonText);
                    console.log('JSON parsed successfully, updating animation');
                    loadAnimation(jsonData);
                    // Update gradient names list
                    updateGradientNamesList();
                } catch (error) {
                    console.error('从编辑器解析 JSON 错误:', error);
                    // 提供更详细的错误信息
                    let errorMessage = '编辑器中的 JSON 无效。请检查您的 JSON 并重试。\n\n';
                    errorMessage += `错误: ${error.message}\n`;
                    if (error.stack) {
                        errorMessage += `堆栈跟踪: ${error.stack}\n`;
                    }
                    errorMessage += `\n内容的前 100 个字符: ${jsonText.substring(0, 100)}${jsonText.length > 100 ? '...' : ''}`;
                    
                    // 用于友好的用户提示
                    alert('编辑器中的 JSON 无效。请检查您的 JSON 并重试。\n\n' + error.message);
                    console.error(errorMessage);
                    // 用错误信息更新渐变名称列表
                    updateGradientNamesList();
                }
            }

            // Handle file upload
            fileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    // Update file info
                    fileInfo.textContent = `Selected file: ${file.name}`;

                    // Read file
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            // Parse JSON
                            const jsonData = JSON.parse(e.target.result);
                            console.log('Successfully parsed JSON file, data type:', typeof jsonData);
                            
                            // Update JSON editor first
                            updateJsonEditor(jsonData);
                            
                            // Load animation
                            loadAnimation(jsonData);
                            
                            // Update gradient names list - use the new reliable function
                            updateGradientNamesList();
                            
                            // Clear any pending debounce timer to prevent duplicate animation loading
                            if (debounceTimer) {
                                clearTimeout(debounceTimer);
                                debounceTimer = null;
                            }
                            
                        } catch (error) {
                            console.error('Error parsing JSON file:', error);
                            alert('无效的 JSON 文件。请选择有效的 Lottie JSON 文件。');
                            fileInfo.textContent = '未选择文件';
                            jsonEditor.value = '';
                            if (animation) {
                                animation.destroy();
                                animation = null;
                            }
                            // Reset gradient names list
                            const gradientNamesList = document.getElementById('gradient-names-list');
                            gradientNamesList.innerHTML = '<p>未找到渐变。上传 JSON 文件以查看渐变。</p>';
                            
                            // Reset editor title
                            if (editorTitle) editorTitle.textContent = '未选择渐变';
                        }
                    };
                    reader.readAsText(file);
                } else {
                    // 重置文件信息
                    fileInfo.textContent = '未选择文件';
                    jsonEditor.value = '';
                    if (animation) {
                        animation.destroy();
                        animation = null;
                    }
                    // 重置渐变名称列表
                    const gradientNamesList = document.getElementById('gradient-names-list');
                    gradientNamesList.innerHTML = '<p>未找到渐变。上传 JSON 文件以查看渐变。</p>';
                    
                    // Reset editor title
                    if (editorTitle) editorTitle.textContent = '未选择渐变';
                }
            });

            // Event listeners for JSON editor buttons
            formatJsonBtn.addEventListener('click', () => {
                // Call formatJson function
                formatJson();
                
                // Update gradient names list after formatting
                // Use a setTimeout to ensure the editor content is updated
                setTimeout(() => {
                    updateGradientNamesList();
                }, 100);
            });
            updateAnimationBtn.addEventListener('click', updateAnimationFromEditor);
            
            // Export functionality
            const exportBtn = document.getElementById('export-btn');
            exportBtn.addEventListener('click', () => {
                const jsonContent = getJsonContent();
                if (!jsonContent.trim()) {
                    alert('No JSON content to export.');
                    return;
                }
                
                // Create a download link
                const blob = new Blob([jsonContent], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `lottie-gradient-${new Date().getTime()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });
            
            // Helper function to update frame display
            function updateTimeDisplay() {
                if (!animation) return;
                // Get total frames and current frame
                const totalFrames = Math.round(animation.totalFrames || 0);
                const currentFrame = Math.round(animation.currentFrame || 0);
                
                if (timeDisplay) {
                    timeDisplay.textContent = `${currentFrame} / ${totalFrames}`;
                }
            }

            // Animation Control Event Listeners
            if (playPauseBtn) {
                playPauseBtn.addEventListener('click', () => {
                    if (!animation) return;
                    if (animation.isPaused) {
                        animation.play();
                        playPauseBtn.innerHTML = pauseIcon;
                    } else {
                        animation.pause();
                        playPauseBtn.innerHTML = playIcon;
                    }
                });
            }
            
            if (progressBar) {
                progressBar.addEventListener('input', () => {
                    isDragging = true;
                    if (!animation) return;
                    const frame = (progressBar.value / 100) * animation.totalFrames;
                    animation.goToAndStop(frame, true);
                    updateTimeDisplay();
                });
                
                progressBar.addEventListener('change', () => {
                    isDragging = false;
                    if (!animation) return;
                    // If the button shows pause icon, it means it should be playing
                    if (playPauseBtn && playPauseBtn.innerHTML.includes('fa-pause')) {
                        animation.play();
                    }
                });
            }
            
            // Background Control Event Listeners
            if (bgColorPicker && bgAlphaBtn) {
                // Initial state
                if (animationContainer.classList.contains('alpha_checkered')) {
                    bgAlphaBtn.classList.add('active');
                } else {
                    // Try to get background color
                    const style = window.getComputedStyle(animationContainer);
                    // Use a simple default or try to parse
                }

                bgColorPicker.addEventListener('input', (e) => {
                    const color = e.target.value;
                    animationContainer.style.backgroundColor = color;
                    animationContainer.classList.remove('alpha_checkered');
                    bgAlphaBtn.classList.remove('active');
                });
                
                bgAlphaBtn.addEventListener('click', () => {
                    if (animationContainer.classList.contains('alpha_checkered')) {
                        // If already active, switch back to color
                        animationContainer.classList.remove('alpha_checkered');
                        bgAlphaBtn.classList.remove('active');
                        animationContainer.style.backgroundColor = bgColorPicker.value;
                    } else {
                        // Enable alpha
                        animationContainer.classList.add('alpha_checkered');
                        bgAlphaBtn.classList.add('active');
                        // Clear background color to let pattern show
                        animationContainer.style.backgroundColor = 'transparent';
                    }
                });
            }
            
            // Expose functions to global scope so they can be called from outside initializeLottiePlayer
            window.getJsonContent = getJsonContent;
            window.loadAnimation = loadAnimation;
            window.updateGradientNamesList = updateGradientNamesList;
            window.updateAnimationFromEditor = updateAnimationFromEditor;
        }
    </script>
</body>
</html>