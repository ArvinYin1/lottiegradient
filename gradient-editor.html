<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gradient Editor</title>
    <!-- Add lottie-web library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/bodymovin/5.12.2/lottie.min.js"></script>
    <!-- Add Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Add highlight.js for syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <!-- Add Monaco Editor for enhanced JSON editing -->
    <link rel="stylesheet" data-name="vs/editor/editor.main" href="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.41.0/min/vs/editor/editor.main.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.41.0/min/vs/loader.js"></script>
    <style>
        /* CSS Variables for Theme Colors */
        :root {
            /* Light Theme */
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-tertiary: #fafafa;
            --bg-input: #ffffff;
            --text-primary: #343a40;
            --text-secondary: #6c757d;
            --border-color: #e0e0e0;
            --border-dark: #ddd;
            --btn-primary: #007bff;
            --btn-danger: #dc3545;
            --btn-secondary: #6c757d;
            --checkered-color: #ccc;
        }
        
        /* Dark Theme */
        [data-theme="dark"] {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --bg-tertiary: #242424;
            --bg-input: #333333;
            --text-primary: #e0e0e0;
            --text-secondary: #b0b0b0;
            --border-color: #444444;
            --border-dark: #555555;
            --btn-primary: #0069d9;
            --btn-danger: #c82333;
            --btn-secondary: #5a6268;
            --checkered-color: #555555;
        }
        
        /* Apply theme variables to all elements */
        * {
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
        }
        
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: var(--bg-primary);
            color: var(--text-primary);
        }
        .playground {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }
        /* Change playground-columns to horizontal layout */
        .playground-columns {
            /* Removed flex-direction: column; to use default row layout */
            flex-wrap: wrap;
        }
        
        /* Ensure each section takes appropriate width */
        #editor {
            flex: 1;
            min-width: 300px;
            background-color: var(--bg-secondary);
            padding: 20px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
        }
        
        .json-viewer {
            display: none;
            flex: 1;
            min-width: 300px;
        }
        .alpha_checkered {
            background-image: linear-gradient(45deg, var(--checkered-color) 25%, transparent 25%), 
                              linear-gradient(-45deg, var(--checkered-color) 25%, transparent 25%), 
                              linear-gradient(45deg, transparent 75%, var(--checkered-color) 75%), 
                              linear-gradient(-45deg, transparent 75%, var(--checkered-color) 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }
        .gradient-preview {
            height: 50px;
            width: 100%;
            border-radius: 4px;
        }
        .gradient-editor {
            display: flex;
            gap: 10px;
            align-items: center;
            margin: 10px 0;
        }
        .gradient-editor input {
            padding: 5px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--bg-input);
            color: var(--text-primary);
        }
        .gradient-editor input[type="color"] {
            width: 50px;
            height: 30px;
            padding: 0;
            border: none;
        }
        .gradient-editor input[type="number"] {
            width: 80px;
        }
        .btn {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .btn-primary {
            background-color: var(--btn-primary);
            color: white;
        }
        .btn-danger {
            background-color: var(--btn-danger);
            color: white;
        }
        .btn-sm {
            padding: 3px 8px;
            font-size: 12px;
        }
        pre {
            background-color: var(--bg-secondary);
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            white-space: pre-wrap;
            color: var(--text-primary);
        }
        code {
            font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
        }
        .json-viewer {
            margin-top: 20px;
        }
        
        /* Lottie Player styles */
        .lottie-player-container {
            margin-top: 50px;
            padding: 20px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background-color: var(--bg-tertiary);
        }
        
        .lottie-player-header {
            margin-bottom: 20px;
        }
        
        .file-upload {
            margin: 20px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .file-input-label {
            display: inline-block;
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 10px;
        }
        
        .file-input {
            display: none;
        }
        
        .export-btn {
            padding: 10px 20px;
            font-size: 14px;
            margin-left: 10px;
        }
        
        .file-info {
            display: inline-block;
            margin-left: 10px;
            font-style: italic;
            color: var(--text-secondary);
        }
        
        .lottie-animation {
            width: 100%;
            height: 400px;
            background-color: var(--bg-primary);
            border: 1px solid var(--border-dark);
            border-radius: 4px;
            margin-top: 20px;
        }
        
        /* Lottie and JSON Editor layout */
        .lottie-editor-wrapper {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        
        .lottie-player-section {
            flex: 1;
            min-width: 0;
        }
        
        .json-editor-section {
            flex: 1;
            min-width: 0;
        }
        
        /* JSON Editor styles */
        .json-editor-section h3 {
            margin-top: 0;
            margin-bottom: 15px;
        }
        
        .json-editor-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .json-editor-container {
            height: 400px;
            border: 1px solid var(--border-dark);
            border-radius: 4px;
            overflow: hidden;
        }
        
        /* Ensure Monaco Editor container has fixed height */
        #monaco-editor-container {
            width: 100%;
            height: 100%;
        }
        
        #json-editor {
            width: 100%;
            height: 100%;
            padding: 15px;
            border: none;
            resize: none;
            font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
            font-size: 14px;
            line-height: 1.5;
            background-color: var(--bg-input);
            color: var(--text-primary);
            box-sizing: border-box;
        }
        
        #json-editor:focus {
            outline: none;
            box-shadow: inset 0 0 0 2px #007bff;
        }
        
        /* Button secondary style */
        .btn-secondary {
            background-color: var(--btn-secondary);
            color: white;
        }
        
        /* Playground layout for left preview and right editor */
        .playground-container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        
        /* Left preview section */
        .preview-section {
            flex: 1;
            min-width: 300px;
            background-color: var(--bg-secondary);
            padding: 20px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
        }
        
        .preview-section h3 {
            margin-top: 0;
            margin-bottom: 20px;
        }
        
        /* Right editor section */
        .json-editor-section-full {
            display: none;
            flex: 2;
            min-width: 400px;
        }
        
        /* Hide JSON editor container */
        .json-editor-section-full .json-editor-container {
            display: none;
        }
        
        /* Gradient Names section */
        .gradient-names-section {
            flex: 1;
            min-width: 250px;
            background-color: var(--bg-secondary);
            padding: 20px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
        }
        
        /* Main gradient section in the top editor area */
        .main-gradient-section {
            max-height: 400px;
            overflow-y: auto;
            margin-right: 20px;
        }
        
        .gradient-names-section h3 {
            margin-top: 0;
            margin-bottom: 20px;
        }
        
        .gradient-names-list {
            max-height: 400px;
            overflow-y: auto;
            background-color: var(--bg-primary);
            border: 1px solid var(--border-dark);
            border-radius: 4px;
            padding: 15px;
        }
        
        .gradient-name-item {
            margin-bottom: 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            overflow: hidden;
            background-color: var(--bg-primary);
        }
        
        .gradient-item-header {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            cursor: pointer;
            background-color: var(--bg-secondary);
            transition: background-color 0.2s;
        }
        
        .gradient-item-header:hover {
            background-color: var(--border-color);
        }
        
        .gradient-name-index {
            font-weight: bold;
            margin-right: 10px;
            color: var(--btn-primary);
        }
        
        .gradient-name {
            flex: 1;
            cursor: pointer;
            text-decoration: underline;
            color: var(--btn-primary);
        }
        
        .gradient-toggle-icon {
            font-size: 12px;
            color: var(--text-secondary);
            transition: transform 0.2s;
        }
        
        .gradient-expandable-content {
            padding: 15px;
            background-color: var(--bg-tertiary);
            border-top: 1px solid var(--border-color);
        }
        
        .gradient-data {
            margin: 0;
        }
        
        .gradient-data h4 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 14px;
            color: var(--text-primary);
        }
        
        .gradient-data pre {
            margin: 0;
            padding: 10px;
            background-color: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            overflow-x: auto;
            font-size: 12px;
            line-height: 1.4;
        }
        
        /* Lottie animation container */
        .lottie-animation {
            width: 100%;
            height: 400px;
            background-color: var(--bg-primary);
            border: 1px solid var(--border-dark);
            border-radius: 4px;
            margin-top: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Responsive design */
        @media (max-width: 1024px) {
            .playground-container {
                flex-direction: column;
            }
            
            .preview-section,
            .json-editor-section-full,
            .gradient-names-section {
                min-width: auto;
            }
        }
        
        /* Theme transition for smooth changes */
        html {
            transition: background-color 0.3s ease;
        }
        
        /* Additional styles for dark theme */
        [data-theme="dark"] {
            /* Ensure proper contrast for text inputs */
            input[type="text"],
            input[type="number"],
            textarea {
                color: var(--text-primary);
                background-color: var(--bg-input);
            }
            
            /* Improve contrast for scrollbars */
            ::-webkit-scrollbar {
                width: 8px;
                height: 8px;
            }
            
            ::-webkit-scrollbar-track {
                background: var(--bg-secondary);
            }
            
            ::-webkit-scrollbar-thumb {
                background: var(--border-dark);
                border-radius: 4px;
            }
            
            ::-webkit-scrollbar-thumb:hover {
                background: var(--btn-secondary);
            }
        }
    </style>
</head>
<body>
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h1>渐变编辑器</h1>
        <button id="theme-toggle" class="btn btn-secondary">
            <i class="fa-solid fa-moon"></i> 深色模式
        </button>
    </div>
    <!-- Lottie Player and JSON Editor Module -->
    <div class="lottie-player-container">
        <h2 class="lottie-player-header">Lottie 动画播放器</h2>
        
        <div class="file-upload">
            <label for="lottie-file" class="file-input-label">
                <i class="fa-solid fa-upload"></i> 上传 Lottie JSON 文件
            </label>
            <input type="file" id="lottie-file" class="file-input" accept=".json">
            <button id="export-btn" class="btn btn-primary export-btn">
                <i class="fa-solid fa-download"></i> 导出 JSON
            </button>
            <span id="file-info" class="file-info">未选择文件</span>
        </div>
        
        <!-- Combined Preview and Editor Section -->
        <div class="playground-container">
            <!-- Left Side: Lottie Animation Preview -->
            <div id="lottie-animation" class="preview-section lottie-animation"></div>
            
            <!-- Middle: JSON Editor -->
            <div class="json-editor-section-full">
                <h3>JSON 编辑器</h3>
                <div class="json-editor-controls">
                    <button id="format-json-btn" class="btn btn-primary btn-sm">
                        <i class="fa-solid fa-code"></i> 格式化 JSON
                    </button>
                    <button id="update-animation-btn" class="btn btn-primary btn-sm">
                        <i class="fa-solid fa-play"></i> 更新动画
                    </button>
                </div>
                
                <div class="json-editor-container">
                    <div id="monaco-editor-container"></div>
                    <!-- Fallback textarea for older browsers -->
                    <textarea id="json-editor" placeholder="上传文件或在此处编辑 JSON..." style="display: none;"></textarea>
                </div>
            </div>
            

        </div>
    </div>

    <div class="playground playground-columns">
        <!-- Left Side: Adobe Gradients -->
        <div class="gradient-names-section main-gradient-section">
            <h3>渐变列表</h3>
            <div id="gradient-names-list" class="gradient-names-list">
                <p>未找到渐变。上传 JSON 文件以查看渐变。</p>
            </div>
        </div>
        
        <!-- Middle: Color Editor -->
        <div id="editor"></div>
        
        <!-- Right Side: Generated JSON -->
        <div class="json-viewer">
            <h3>生成的 JSON</h3>
            <pre><code class="language-json" id="json_viewer"></code></pre>
        </div>
    </div>

    <script>
        // Helper functions
        function truncate_float(num) {
            return Math.round(num * 1000) / 1000;
        }

        function color_lottie_to_hex(lottie) {
            let r = Math.round(lottie[0] * 255).toString(16).padStart(2, '0');
            let g = Math.round(lottie[1] * 255).toString(16).padStart(2, '0');
            let b = Math.round(lottie[2] * 255).toString(16).padStart(2, '0');
            return `#${r}${g}${b}`;
        }

        function color_hex_to_lottie(hex) {
            let r = parseInt(hex.slice(1, 3), 16) / 255;
            let g = parseInt(hex.slice(3, 5), 16) / 255;
            let b = parseInt(hex.slice(5, 7), 16) / 255;
            return [r, g, b];
        }

        function color_lottie_to_hex_component(alpha) {
            let a = Math.round(alpha * 255).toString(16).padStart(2, '0');
            return a;
        }

        // GradientPreviewEditor class
        class GradientPreviewEditor {
            constructor(parent, lottie, color_count, on_change, dynamic_count = false) {
                this.on_change = on_change;
                this.with_alpha = lottie.length >= color_count * 6;
                if (lottie.length < color_count * 4) {
                    color_count = Math.floor(lottie.length / 4);
                }

                let self = this;
                this.colors = [];

                // First create preview container and gradient-preview div
                let preview_cont = parent.appendChild(document.createElement("div"));
                preview_cont.classList.add("alpha_checkered");

                this.preview = preview_cont.appendChild(document.createElement("div"));
                this.preview.classList.add("gradient-preview");
                this.preview.setAttribute("style", "background:" + this.to_css());

                // Then create the label with checkbox
                let label = parent.appendChild(document.createElement("p"))
                    .appendChild(document.createElement("label"));
                let check_apha = label.appendChild(document.createElement("input"));
                check_apha.type = "checkbox";
                check_apha.checked = this.with_alpha;
                check_apha.addEventListener("input", () => {
                    self.with_alpha = check_apha.checked;
                    for (let color of self.colors) {
                        color.alpha_input.style.display = self.with_alpha ? "inline-block" : "none";
                    }
                    self._on_change();
                });
                label.appendChild(document.createTextNode(" 启用 Alpha"));

                this.parent = parent.appendChild(document.createElement("div"));
                for (let i = 0; i < color_count; i++) {
                    this.add_color(
                        lottie[i * 4],
                        color_lottie_to_hex(lottie.slice(i * 4 + 1, i * 4 + 4)),
                        this.with_alpha ? lottie[4 * color_count + i * 2 + 1] : 1,
                        dynamic_count
                    );
                }

                if (dynamic_count) {
                    let btn = parent.appendChild(document.createElement("button"));
                    btn.setAttribute("class", "btn btn-primary btn-sm");
                    btn.title = "添加色标";
                    btn.innerHTML = "<i class='fa-solid fa-plus'></i> 添加色标";
                    btn.addEventListener("click", () => {
                        self.add_color(1, "#000000", 1, true);
                        self._on_change();
                    });
                }
            }

            add_color(offset, hex, alpha, dynamic_count) {
                let self = this;
                let color = {
                    offset: offset,
                    color: hex,
                    alpha: alpha,
                };
                this.colors.push(color);

                let p = this.parent.appendChild(document.createElement("p"));
                p.classList.add("gradient-editor");
                let in_off = p.appendChild(document.createElement("input"));
                in_off.title = "Offset";
                in_off.type = "number";
                in_off.min = 0;
                in_off.max = 1;
                in_off.step = 0.01;
                in_off.value = color.offset;
                in_off.addEventListener("input", () => {
                    color.offset = Number(in_off.value);
                    self._on_change();
                });

                let in_col = p.appendChild(document.createElement("input"));
                in_col.type = "color";
                in_col.value = color.color;
                in_col.addEventListener("input", () => {
                    color.color = in_col.value;
                    self._on_change();
                });

                let in_alpha = p.appendChild(document.createElement("input"));
                in_alpha.title = "Alpha";
                in_alpha.type = "number";
                in_alpha.min = 0;
                in_alpha.max = 1;
                in_alpha.step = 0.01;
                in_alpha.value = color.alpha;
                in_alpha.style.display = this.with_alpha ? "inline-block" : "none";
                in_alpha.addEventListener("input", () => {
                    color.alpha = Number(in_alpha.value);
                    self._on_change();
                });
                color.alpha_input = in_alpha;

                if (dynamic_count) {
                    let btn = p.appendChild(document.createElement("button"));
                    btn.setAttribute("class", "btn btn-danger btn-sm");
                    btn.title = "删除色标";
                    btn.innerHTML = "<i class='fa-solid fa-minus'></i> 删除";
                    btn.addEventListener("click", () => {
                        self.parent.removeChild(p);
                        self.colors.splice(self.colors.indexOf(color), 1);
                        self._on_change();
                    });
                }
            }

            to_css() {
                let items = [];
                for (let color of this.colors) {
                    let stop = color.color;
                    if (this.with_alpha) {
                        stop += color_lottie_to_hex_component(color.alpha);
                    }
                    stop += " " + (color.offset * 100) + "%";
                    items.push(stop);
                }
                return "linear-gradient(90deg, " + items.join(",") + ")";
            }

            _on_change() {
                let lottie = [];
                let alpha = [];
                for (let color of this.colors) {
                    lottie.push(color.offset, ...color_hex_to_lottie(color.color));
                    if (this.with_alpha) {
                        alpha.push(color.offset, color.alpha);
                    }
                }

                this.preview.setAttribute("style", "background:" + this.to_css());
                this.on_change(lottie.concat(alpha));
            }

            // Method to update the gradient with new data
            update(lottie, color_count) {
                // Clear existing colors and UI
                this.parent.innerHTML = '';
                this.colors = [];
                
                // Recalculate alpha support
                this.with_alpha = lottie.length >= color_count * 6;
                if (lottie.length < color_count * 4) {
                    color_count = Math.floor(lottie.length / 4);
                }
                
                // Recreate color inputs
                for (let i = 0; i < color_count; i++) {
                    this.add_color(
                        lottie[i * 4],
                        color_lottie_to_hex(lottie.slice(i * 4 + 1, i * 4 + 4)),
                        this.with_alpha ? lottie[4 * color_count + i * 2 + 1] : 1,
                        true // dynamic_count
                    );
                }
                
                // Update the preview
                this._on_change();
            }
            
            static stand_alone(parent, on_change) {
                let initial = [0, 0.161, 0.184, 0.459, 0.5, 0.196, 0.314, 0.69, 1, 0.769, 0.851, 0.961];
                on_change(initial);
                return new GradientPreviewEditor(parent, initial, 3, on_change, true);
            }
        }

        // Initialize the editor when the page loads
        let gradientEditorInstance = null;
        let selectedGradientInfo = null; // Store information about the currently selected gradient
        let monacoEditor = null; // Global reference to Monaco Editor
        let animation = null; // Global reference to Lottie animation
        
        document.addEventListener('DOMContentLoaded', () => {
            // Theme Toggle Logic
            const themeToggle = document.getElementById('theme-toggle');
            const body = document.body;
            
            // Check for saved theme in localStorage or use system preference
            const savedTheme = localStorage.getItem('theme');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            
            // Set initial theme
            const initialTheme = savedTheme || (prefersDark ? 'dark' : 'light');
            body.setAttribute('data-theme', initialTheme);
            
            // Update button text and icon based on current theme
            const updateThemeButton = () => {
                const currentTheme = body.getAttribute('data-theme');
                if (currentTheme === 'dark') {
                    themeToggle.innerHTML = '<i class="fa-solid fa-sun"></i> 浅色模式';
                } else {
                    themeToggle.innerHTML = '<i class="fa-solid fa-moon"></i> 深色模式';
                }
            };
            
            // Call once to set initial button state
            updateThemeButton();
            
            // Add click event listener for theme toggle
            themeToggle.addEventListener('click', () => {
                const currentTheme = body.getAttribute('data-theme');
                const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                
                // Update theme attribute on body
                body.setAttribute('data-theme', newTheme);
                
                // Save theme preference to localStorage
                localStorage.setItem('theme', newTheme);
                
                // Update button text and icon
                updateThemeButton();
            });
            
            // Initialize Gradient Editor
            gradientEditorInstance = GradientPreviewEditor.stand_alone(document.getElementById("editor"), (lottie) => {
                var raw_json = JSON.stringify(lottie, undefined, 4);
                document.getElementById("json_viewer").innerHTML = raw_json;
                
                // If a gradient is selected, update it in the JSON editor
                if (selectedGradientInfo) {
                    updateGradientInJson(lottie);
                }
            });

            // Initialize Lottie Player
            initializeLottiePlayer();
        });
        
        // Function to update the selected gradient in the JSON editor
        function updateGradientInJson(newGradientData) {
            // Get current JSON content from Monaco Editor
            if (monacoEditor) {
                try {
                    const jsonContent = monacoEditor.getValue();
                    const jsonData = JSON.parse(jsonContent);
                    
                    // Find and update the gradient in the JSON data
                    updateGradientInJsonData(jsonData, selectedGradientInfo, newGradientData);
                    
                    // Update the Monaco Editor with the modified JSON
                    const updatedJsonContent = JSON.stringify(jsonData, null, 2);
                    monacoEditor.setValue(updatedJsonContent);
                    
                    // Auto-update the animation preview
                    updateAnimationFromEditor();
                } catch (error) {
                    console.error('Error updating gradient in JSON:', error);
                }
            }
        }
        
        // Recursive function to find and update the gradient in JSON data
        function updateGradientInJsonData(jsonData, gradientInfo, newGradientData) {
            let updated = false;
            // Check if this is the object containing the gradient
            if (typeof jsonData === 'object' && jsonData !== null) {
                // If it's the gradient object, update its "k" property
                if (jsonData.ty === 'gf' && jsonData.nm === gradientInfo.name) {
                    if (jsonData.g) {
                        // Calculate new color count based on newGradientData length
                        // Each color stop has 4 values (offset, r, g, b) without alpha
                        const newColorCount = Math.floor(newGradientData.length / 4);
                        
                        // Update the gradient data
                        if (jsonData.g.k && typeof jsonData.g.k === 'object' && 'k' in jsonData.g.k) {
                            // Handle nested k structure: g.k is an object with a k property
                            jsonData.g.k.k = newGradientData;
                            // Update the color count (p property) in the gradient
                            if (jsonData.g.p !== undefined) {
                                jsonData.g.p = newColorCount;
                            }
                        } else {
                            // Handle direct k structure: g.k is the array directly
                            jsonData.g.k = newGradientData;
                            // Update the color count (p property) in the gradient
                            if (jsonData.g.p !== undefined) {
                                jsonData.g.p = newColorCount;
                            }
                        }
                        updated = true;
                    }
                }
                
                // Recursively check all properties
                for (const key in jsonData) {
                    if (jsonData.hasOwnProperty(key)) {
                        const value = jsonData[key];
                        if (typeof value === 'object' && value !== null) {
                            if (updateGradientInJsonData(value, gradientInfo, newGradientData)) {
                                updated = true;
                            }
                        }
                    }
                }
            } else if (Array.isArray(jsonData)) {
                // Check each item in the array
                for (const item of jsonData) {
                    if (updateGradientInJsonData(item, gradientInfo, newGradientData)) {
                        updated = true;
                    }
                }
            }
            return updated;
        }

        // Lottie Player and JSON Editor functions
        function initializeLottiePlayer() {
            let debounceTimer = null;
            const fileInput = document.getElementById('lottie-file');
            const fileInfo = document.getElementById('file-info');
            const animationContainer = document.getElementById('lottie-animation');
            const jsonEditor = document.getElementById('json-editor');
            const formatJsonBtn = document.getElementById('format-json-btn');
            const updateAnimationBtn = document.getElementById('update-animation-btn');
            
            // Initialize Monaco Editor
            function initMonacoEditor() {
                require.config({
                    paths: {
                        'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.41.0/min/vs'
                    }
                });

                require(['vs/editor/editor.main'], function() {
                    // Ensure the container has proper dimensions before initializing
                    const container = document.getElementById('monaco-editor-container');
                    
                    // Force the container to have the correct height
                    container.style.display = 'block';
                    container.style.width = '100%';
                    container.style.height = '400px';
                    
                    monacoEditor = monaco.editor.create(container, {
                        value: '',
                        language: 'json',
                        theme: 'vs',
                        automaticLayout: true,
                        minimap: {
                            enabled: true
                        },
                        scrollBeyondLastLine: false,
                        wordWrap: 'on',
                        formatOnPaste: true,
                        formatOnType: true,
                        tabSize: 2,
                        lineNumbers: 'on',
                        glyphMargin: true,
                        folding: true,
                        scrollbar: {
                            vertical: 'visible',
                            horizontal: 'visible',
                            useShadows: false
                        }
                    });

                    // Add JSON validation
                    monaco.languages.json.jsonDefaults.setDiagnosticsOptions({
                        validate: true,
                        schemas: []
                    });
                    
                    // Update editor when window is resized
                    window.addEventListener('resize', function() {
                        monacoEditor.layout();
                    });
                    
                    // Add change listener for auto-update functionality
                    monacoEditor.onDidChangeModelContent(function() {
                        // Auto-update animation when editor content changes
                        // Use debounce to avoid excessive updates
                        if (debounceTimer) {
                            clearTimeout(debounceTimer);
                        }
                        debounceTimer = setTimeout(function() {
                            updateAnimationFromEditor();
                            // Update gradient names list when editor content changes
                            updateGradientNamesList();
                        }, 500); // 500ms debounce
                    });
                });
            }
            
            // Initialize Monaco Editor when DOM is ready and container is properly sized
            if (typeof require !== 'undefined') {
                // Use setTimeout to ensure DOM is fully rendered
                setTimeout(initMonacoEditor, 100);
            } else {
                // Fallback if require is not available (older browsers)
                document.getElementById('json-editor').style.display = 'block';
                document.getElementById('monaco-editor-container').style.display = 'none';
            }
            
            // Add a check to ensure editor content is properly synced
            function ensureContentSynced() {
                if (monacoEditor && jsonEditor.value !== monacoEditor.getValue()) {
                    console.log('Syncing textarea with Monaco Editor content');
                    jsonEditor.value = monacoEditor.getValue();
                }
            }
            
            // Sync content every second for safety
            setInterval(ensureContentSynced, 1000);

            // Function to load and play Lottie animation
            function loadAnimation(jsonData) {
                try {
                    console.log('Loading animation with data:', JSON.stringify(jsonData).substring(0, 100) + '...');
                    
                    // Destroy existing animation if any
                    if (animation) {
                        console.log('Destroying existing animation');
                        animation.destroy();
                        animation = null;
                    }

                    // Load new animation
                    console.log('Creating new animation with bodymovin');
                    animation = bodymovin.loadAnimation({
                        container: animationContainer,
                        renderer: 'svg',
                        loop: true,
                        autoplay: true,
                        animationData: jsonData
                    });
                    console.log('Animation created successfully');
                    
                    // Add animation event listeners for debugging
                    animation.addEventListener('DOMLoaded', () => {
                        console.log('Animation DOMLoaded event fired');
                    });
                    
                    animation.addEventListener('loopComplete', () => {
                        console.log('Animation loopComplete event fired');
                    });
                    
                    animation.addEventListener('complete', () => {
                        console.log('Animation complete event fired');
                    });
                    
                    animation.addEventListener('error', (error) => {
                        console.error('Animation error event fired:', error);
                    });
                    
                } catch (error) {
                    console.error('Error loading animation:', error);
                    alert('Error loading animation: ' + error.message);
                }
            }

            // Function to update JSON editor content
            function updateJsonEditor(jsonData) {
                const jsonString = JSON.stringify(jsonData, undefined, 2);
                console.log('Updating JSON editor with content:', jsonString.substring(0, 100) + (jsonString.length > 100 ? '...' : ''));
                
                if (monacoEditor) {
                    monacoEditor.setValue(jsonString);
                    console.log('Monaco Editor content updated successfully');
                }
                jsonEditor.value = jsonString;
            }

            // Function to get JSON content from editor
            function getJsonContent() {
                let content = '';
                
                // Check if Monaco Editor is available and has content
                if (monacoEditor) {
                    try {
                        content = monacoEditor.getValue();
                        console.log('Got content from Monaco Editor, length:', content.length);
                    } catch (e) {
                        console.error('Error getting content from Monaco Editor:', e.message);
                        // Fallback to textarea
                        content = jsonEditor.value;
                    }
                } else {
                    content = jsonEditor.value;
                }
                
                // Ensure we have valid content
                if (!content.trim()) {
                    console.log('Content is empty, returning empty string');
                }
                
                return content;
            }
            
            // Function to format JSON in editor
            function formatJson() {
                const jsonText = getJsonContent();
                if (jsonText.trim() === '') {
                    return;
                }

                try {
                    const jsonData = JSON.parse(jsonText);
                    updateJsonEditor(jsonData);
                    
                    // If Monaco Editor is available, use its format command
                    if (monacoEditor) {
                        monacoEditor.getAction('editor.action.formatDocument').run();
                    }
                } catch (error) {
                    console.error('Error formatting JSON:', error);
                    alert('Invalid JSON format. Please check your JSON and try again.');
                }
            }

            // Function to find all Adobe gradient names in JSON
            function findAdobeGradientNames(jsonData) {
                const gradients = [];
                const foundNames = new Set(); // Use Set to track unique gradient names
                
                // Recursive function to traverse JSON and find gradients with their "g" data
                function traverse(obj, parent = null, path = []) {
                    if (obj === null || typeof obj !== 'object') {
                        return;
                    }
                    
                    // Check if this is a gradient fill object
                    if (obj.ty === 'gf' && obj.mn === 'ADBE Vector Graphic - G-Fill' && obj.nm) {
                        const name = obj.nm;
                        // Only add each gradient name once, regardless of how many times it appears
                        if (!foundNames.has(name)) {
                            foundNames.add(name);
                            gradients.push({
                                name: name,
                                gradientData: obj.g || {}, // Store the "g" tag content
                                parent: parent,
                                path: path.join('.') // Store the path for debugging
                            });
                        }
                    }
                    
                    // If this object has a shapes array, check its items
                    if (obj.shapes && Array.isArray(obj.shapes)) {
                        for (const shape of obj.shapes) {
                            traverse(shape, obj, [...path, 'shapes']);
                        }
                    }
                    
                    // If this is an array, check all items
                    if (Array.isArray(obj)) {
                        for (let i = 0; i < obj.length; i++) {
                            traverse(obj[i], obj, [...path, i]);
                        }
                    }
                    
                    // If this is an object, check all properties
                    else if (typeof obj === 'object') {
                        for (const key in obj) {
                            traverse(obj[key], obj, [...path, key]);
                        }
                    }
                }
                
                // Start traversal
                traverse(jsonData);
                
                return gradients;
            }
            
            // Function to update gradient names list
            function updateGradientNamesList() {
                const gradientNamesList = document.getElementById('gradient-names-list');
                
                try {
                    // First try to use animationData (already parsed JSON from animation)
                    if (animation && animation.animationData) {
                        console.log('Using animationData for gradient names');
                        const gradients = findAdobeGradientNames(animation.animationData);
                        
                        if (gradients.length === 0) {
                            gradientNamesList.innerHTML = '<p>JSON 文件中未找到渐变。</p>';
                        } else {
                            // Clear existing content
                            gradientNamesList.innerHTML = '';
                            
                            // Create and add gradient items
                            gradients.forEach((gradient, index) => {
                                // Create main gradient item
                                const gradientItem = document.createElement('div');
                                gradientItem.className = 'gradient-name-item';
                                gradientItem.innerHTML = `
                                    <div class="gradient-item-header">
                                        <span class="gradient-name-index">${index + 1}.</span>
                                        <span class="gradient-name">${gradient.name}</span>
                                    </div>
                                `;
                                
                                // Add click event for navigation
                                const gradientNameElement = gradientItem.querySelector('.gradient-name');
                                gradientNameElement.addEventListener('click', function() {
                                    const gradientName = gradient.name;
                                    console.log('Clicked gradient:', gradientName);
                                    
                                    // Store information about the selected gradient
                                    selectedGradientInfo = {
                                        name: gradient.name,
                                        gradientData: gradient.gradientData
                                    };
                                    
                                    // Update Gradient Editor with the clicked gradient's data
                                    if (gradientEditorInstance && gradient.gradientData && gradient.gradientData.k) {
                                        console.log('Updating Gradient Editor with:', gradient.gradientData);
                                        const gradientData = gradient.gradientData;
                                        
                                        // Handle both direct array format and nested object format for k
                                        let gradientK = gradientData.k;
                                        if (typeof gradientK === 'object' && gradientK !== null && gradientK.k) {
                                            // Nested format: k.k contains the actual color stops
                                            gradientK = gradientK.k;
                                        }
                                        
                                        // Calculate color stop count
                                        const colorCount = gradientData.p || Math.floor(gradientK.length / 4);
                                        gradientEditorInstance.update(gradientK, colorCount);
                                    }
                                    
                                    if (monacoEditor) {
                                        console.log('Using Monaco Editor for navigation');
                                        
                                        // Get editor content
                                        const content = monacoEditor.getValue();
                                        
                                        // Find the gradient in the content
                                        const searchText = `"nm":"${gradientName}"`;
                                        const index = content.indexOf(searchText);
                                        
                                        if (index !== -1) {
                                            console.log('Found gradient at index:', index);
                                            
                                            // Calculate line and column
                                            const lines = content.substring(0, index).split('\n');
                                            const line = lines.length - 1;
                                            const column = lines[line].length;
                                            
                                            console.log('Line:', line, 'Column:', column);
                                            
                                            // Set selection and reveal
                                            monacoEditor.setPosition({ lineNumber: line + 1, column: column + 1 });
                                            monacoEditor.revealPositionInCenter({ lineNumber: line + 1, column: column + 1 });
                                            monacoEditor.focus();
                                            
                                            console.log('Navigation completed');
                                        } else {
                                            console.log('Gradient not found in content');
                                        }
                                    } else {
                                        console.log('Monaco Editor not available');
                                    }
                                });
                                
                                // Add hover effect
                                gradientItem.style.cursor = 'pointer';
                                gradientItem.style.transition = 'background-color 0.2s';
                                gradientItem.addEventListener('mouseenter', () => {
                                    gradientItem.style.backgroundColor = '#f0f0f0';
                                });
                                gradientItem.addEventListener('mouseleave', () => {
                                    gradientItem.style.backgroundColor = 'transparent';
                                });
                                
                                // Add to list
                                gradientNamesList.appendChild(gradientItem);
                            });
                        }
                        return;
                    }
                    
                    // If no animationData, try to get from editor
                    const jsonText = getJsonContent();
                    if (jsonText.trim() === '') {
                        gradientNamesList.innerHTML = '<p>未找到渐变。上传 JSON 文件以查看渐变。</p>';
                        return;
                    }
                    
                    // Try to parse JSON from editor content
                    const jsonData = JSON.parse(jsonText);
                    const gradients = findAdobeGradientNames(jsonData);
                    
                    if (gradients.length === 0) {
                        gradientNamesList.innerHTML = '<p>JSON 文件中未找到渐变。</p>';
                    } else {
                        // Clear existing content
                        gradientNamesList.innerHTML = '';
                        
                        // Create and add gradient items with expand/collapse functionality
                        gradients.forEach((gradient, index) => {
                            // Create main gradient item
                            const gradientItem = document.createElement('div');
                            gradientItem.className = 'gradient-name-item';
                            gradientItem.innerHTML = `
                                <div class="gradient-item-header">
                                    <span class="gradient-name-index">${index + 1}.</span>
                                    <span class="gradient-name">${gradient.name}</span>
                                </div>
                            `;
                            
                            // Add click event for navigation
                            const gradientNameElement = gradientItem.querySelector('.gradient-name');
                            gradientNameElement.addEventListener('click', function() {
                                const gradientName = gradient.name;
                                console.log('Clicked gradient:', gradientName);
                                
                                // Update Gradient Editor with the clicked gradient's data
                                if (gradientEditorInstance && gradient.gradientData && gradient.gradientData.k) {
                                    console.log('Updating Gradient Editor with:', gradient.gradientData);
                                    const gradientData = gradient.gradientData;
                                    
                                    // Handle both direct array format and nested object format for k
                                    let gradientK = gradientData.k;
                                    if (typeof gradientK === 'object' && gradientK !== null && gradientK.k) {
                                        // Nested format: k.k contains the actual color stops
                                        gradientK = gradientK.k;
                                    }
                                    
                                    // Calculate color stop count
                                    const colorCount = gradientData.p || Math.floor(gradientK.length / 4);
                                    gradientEditorInstance.update(gradientK, colorCount);
                                }
                                
                                if (monacoEditor) {
                                    console.log('Using Monaco Editor for navigation');
                                    
                                    // Get editor content
                                    const content = monacoEditor.getValue();
                                    
                                    // Find the gradient in the content
                                    const searchText = `"nm":"${gradientName}"`;
                                    const index = content.indexOf(searchText);
                                    
                                    if (index !== -1) {
                                        console.log('Found gradient at index:', index);
                                        
                                        // Calculate line and column
                                        const lines = content.substring(0, index).split('\n');
                                        const line = lines.length - 1;
                                        const column = lines[line].length;
                                        
                                        console.log('Line:', line, 'Column:', column);
                                        
                                        // Set selection and reveal
                                        monacoEditor.setPosition({ lineNumber: line + 1, column: column + 1 });
                                        monacoEditor.revealPositionInCenter({ lineNumber: line + 1, column: column + 1 });
                                        monacoEditor.focus();
                                        
                                        console.log('Navigation completed');
                                    } else {
                                        console.log('Gradient not found in content');
                                    }
                                } else {
                                    console.log('Monaco Editor not available');
                                }
                            });
                            
                            // Add hover effect
                            gradientItem.style.cursor = 'pointer';
                            gradientItem.style.transition = 'background-color 0.2s';
                            gradientItem.addEventListener('mouseenter', () => {
                                gradientItem.style.backgroundColor = '#f0f0f0';
                            });
                            gradientItem.addEventListener('mouseleave', () => {
                                gradientItem.style.backgroundColor = 'transparent';
                            });
                            
                            // Add to list
                            gradientNamesList.appendChild(gradientItem);
                        });
                    }
                } catch (error) {
                    console.error('updateGradientNamesList 错误:', error.message);
                    // 显示友好的错误信息，而不是无效的 JSON
                    gradientNamesList.innerHTML = '<p>JSON 文件中未找到渐变。</p>';
                }
            }
            
            // Function to update animation from JSON editor
            function updateAnimationFromEditor() {
                const jsonText = getJsonContent();
                if (jsonText.trim() === '') {
                    alert('请先输入或上传 JSON 文件。');
                    return;
                }

                try {
                    console.log('Attempting to parse JSON:', jsonText.substring(0, 100) + (jsonText.length > 100 ? '...' : ''));
                    const jsonData = JSON.parse(jsonText);
                    console.log('JSON parsed successfully, updating animation');
                    loadAnimation(jsonData);
                    // Update gradient names list
                    updateGradientNamesList();
                } catch (error) {
                    console.error('从编辑器解析 JSON 错误:', error);
                    // 提供更详细的错误信息
                    let errorMessage = '编辑器中的 JSON 无效。请检查您的 JSON 并重试。\n\n';
                    errorMessage += `错误: ${error.message}\n`;
                    if (error.stack) {
                        errorMessage += `堆栈跟踪: ${error.stack}\n`;
                    }
                    errorMessage += `\n内容的前 100 个字符: ${jsonText.substring(0, 100)}${jsonText.length > 100 ? '...' : ''}`;
                    
                    // 用于友好的用户提示
                    alert('编辑器中的 JSON 无效。请检查您的 JSON 并重试。\n\n' + error.message);
                    console.error(errorMessage);
                    // 用错误信息更新渐变名称列表
                    updateGradientNamesList();
                }
            }

            // Handle file upload
            fileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    // Update file info
                    fileInfo.textContent = `Selected file: ${file.name}`;

                    // Read file
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            // Parse JSON
                            const jsonData = JSON.parse(e.target.result);
                            console.log('Successfully parsed JSON file, data type:', typeof jsonData);
                            
                            // Load animation
                            loadAnimation(jsonData);
                            // Update JSON editor
                            updateJsonEditor(jsonData);
                            
                            // Update gradient names list - use the new reliable function
                            updateGradientNamesList();
                            
                        } catch (error) {
                            console.error('Error parsing JSON file:', error);
                            alert('无效的 JSON 文件。请选择有效的 Lottie JSON 文件。');
                            fileInfo.textContent = '未选择文件';
                            jsonEditor.value = '';
                            if (animation) {
                                animation.destroy();
                                animation = null;
                            }
                            // Reset gradient names list
                            const gradientNamesList = document.getElementById('gradient-names-list');
                            gradientNamesList.innerHTML = '<p>未找到渐变。上传 JSON 文件以查看渐变。</p>';
                        }
                    };
                    reader.readAsText(file);
                } else {
                    // 重置文件信息
                    fileInfo.textContent = '未选择文件';
                    jsonEditor.value = '';
                    if (animation) {
                        animation.destroy();
                        animation = null;
                    }
                    // 重置渐变名称列表
                    const gradientNamesList = document.getElementById('gradient-names-list');
                    gradientNamesList.innerHTML = '<p>未找到渐变。上传 JSON 文件以查看渐变。</p>';
                }
            });

            // Event listeners for JSON editor buttons
            formatJsonBtn.addEventListener('click', () => {
                // Call formatJson function
                formatJson();
                
                // Update gradient names list after formatting
                // Use a setTimeout to ensure the editor content is updated
                setTimeout(() => {
                    updateGradientNamesList();
                }, 100);
            });
            updateAnimationBtn.addEventListener('click', updateAnimationFromEditor);
            
            // Export functionality
            const exportBtn = document.getElementById('export-btn');
            exportBtn.addEventListener('click', () => {
                const jsonContent = getJsonContent();
                if (!jsonContent.trim()) {
                    alert('No JSON content to export.');
                    return;
                }
                
                // Create a download link
                const blob = new Blob([jsonContent], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `lottie-gradient-${new Date().getTime()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });
            
            // Expose functions to global scope so they can be called from outside initializeLottiePlayer
            window.getJsonContent = getJsonContent;
            window.loadAnimation = loadAnimation;
            window.updateGradientNamesList = updateGradientNamesList;
            window.updateAnimationFromEditor = updateAnimationFromEditor;
        }
    </script>
</body>
</html>