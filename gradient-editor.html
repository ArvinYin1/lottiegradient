<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gradient Editor</title>
    <!-- Add lottie-web library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/bodymovin/5.12.2/lottie.min.js"></script>
    <!-- Add Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Add highlight.js for syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <!-- Add Monaco Editor for enhanced JSON editing -->
    <link rel="stylesheet" data-name="vs/editor/editor.main" href="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.41.0/min/vs/editor/editor.main.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.41.0/min/vs/loader.js"></script>
    <style>
        /* CSS Variables for Theme Colors */
        :root {
            /* Light Theme */
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-tertiary: #fafafa;
            --bg-input: #ffffff;
            --text-primary: #343a40;
            --text-secondary: #6c757d;
            --border-color: #e0e0e0;
            --border-dark: #ddd;
            --btn-primary: #007bff;
            --btn-success: #28a745;
            --btn-danger: #dc3545;
            --btn-secondary: #6c757d;
            --checkered-color: #ccc;
        }
        
        /* Dark Theme */
        [data-theme="dark"] {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --bg-tertiary: #242424;
            --bg-input: #333333;
            --text-primary: #e0e0e0;
            --text-secondary: #b0b0b0;
            --border-color: #444444;
            --border-dark: #555555;
            --btn-primary: #0069d9;
            --btn-success: #218838;
            --btn-danger: #c82333;
            --btn-secondary: #5a6268;
            --checkered-color: #555555;
        }
        
        /* Apply theme variables to all elements */
        * {
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
        }
        
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            height: calc(100vh - 40px);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Lottie Player styles */
        .lottie-player-container {
            margin-top: 0;
            padding: 20px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background-color: var(--bg-tertiary);
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .lottie-player-header {
            margin-bottom: 20px;
        }
        
        .header-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
            gap: 20px;
            flex-wrap: wrap;
        }

        .title-section {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .controls-section {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .file-upload {
            margin: 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px; /* Rounded corners */
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            line-height: 1.2;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-primary {
            background-color: var(--btn-primary);
            color: white;
        }

        .btn-primary:hover {
            background-color: #0056b3;
        }

        .btn-success {
            background-color: var(--btn-success);
            color: white;
        }

        .btn-success:hover {
            background-color: #1e7e34;
        }
        
        .btn-danger {
            background-color: var(--btn-danger);
            color: white;
        }

        .btn-danger:hover {
            background-color: #c82333;
        }

        .btn-sm {
            padding: 4px 10px;
            font-size: 12px;
            border-radius: 4px;
        }
        
        .header-btn {
            height: 36px;
            padding: 0 16px;
            font-size: 14px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            white-space: nowrap;
            border-radius: 6px; /* Ensure rounded corners */
        }

        .header-btn i {
            font-size: 14px;
            width: 16px; /* Ensure fixed width for icons to prevent layout shift */
            text-align: center;
        }

        .file-input-label {
             /* Styles will be replaced by general button styles below */
             margin-right: 0;
             line-height: 1.2;
        }
        
        .file-input {
            display: none;
        }
        
        .export-btn {
             /* Styles will be replaced by general button styles below */
        }
        
        .file-info {
            display: inline-block;
            margin-left: 10px;
            font-style: italic;
            color: var(--text-secondary);
        }
        
        .lottie-animation {
            width: 100%;
            height: 100%; /* Fill available space */
            background-color: var(--bg-primary);
            border: 1px solid var(--border-dark);
            border-radius: 4px;
            margin-top: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            flex: 1;
        }
        
        /* Lottie and JSON Editor layout */
        .lottie-editor-wrapper {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        
        .lottie-player-section {
            flex: 1;
            min-width: 0;
        }
        
        .json-editor-section {
            flex: 1;
            min-width: 0;
        }
        
        /* JSON Editor styles */
        .json-editor-section h3 {
            margin-top: 0;
            margin-bottom: 15px;
        }
        
        .json-editor-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .json-editor-container {
            height: 400px;
            border: 1px solid var(--border-dark);
            border-radius: 4px;
            overflow: hidden;
        }
        
        /* Ensure Monaco Editor container has fixed height */
        #monaco-editor-container {
            width: 100%;
            height: 100%;
        }
        
        #json-editor {
            width: 100%;
            height: 100%;
            padding: 15px;
            border: none;
            resize: none;
            font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
            font-size: 14px;
            line-height: 1.5;
            background-color: var(--bg-input);
            color: var(--text-primary);
            box-sizing: border-box;
        }
        
        #json-editor:focus {
            outline: none;
            box-shadow: inset 0 0 0 2px #007bff;
        }
        
        .btn-flat-primary {
            background-color: var(--btn-primary);
            color: white;
            border: none;
            box-shadow: none !important;
            transform: none !important; /* Disable lift effect */
        }

        .btn-flat-primary:hover {
            background-color: #0056b3;
            transform: none !important;
            box-shadow: none !important;
        }

        /* Button secondary style */
        .btn-secondary {
            background-color: var(--btn-secondary);
            color: white;
        }
        
        /* Playground layout for left preview and right editor */
        .playground-container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            flex: 1;
            min-height: 0; /* Important for nested flex scroll */
        }
        
        /* Left preview section */
        .preview-section {
            flex: 2; /* Increased width for player */
            min-width: 300px;
            background-color: var(--bg-secondary);
            padding: 20px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
        }
        
        .preview-section h3 {
            margin-top: 0;
            margin-bottom: 20px;
        }
        
        /* Right editor section */
        .editor-section {
            flex: 2; /* Increased width to accommodate horizontal layout */
            min-width: 500px;
            display: flex;
            flex-direction: row; /* Changed to row for horizontal layout */
            gap: 20px;
            overflow: hidden; /* Prevent outer scroll */
        }

        .json-editor-section-full {
            display: none;
            /* Moved styles to general structure */
        }
        
        /* Gradient Names section */
        .gradient-names-section {
            background-color: var(--bg-secondary);
            padding: 20px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            flex: 1; /* Take up half width */
            overflow: hidden; /* Contain scroll */
        }
        
        /* Color Editor section */
        .editor-container {
            background-color: var(--bg-secondary);
            padding: 20px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            flex: 1; /* Take up half width */
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #editor-title {
            margin-top: 0;
            margin-bottom: 20px;
            flex-shrink: 0;
        }

        #editor {
            overflow-y: auto; /* Allow scrolling within editor if needed */
            flex: 1;
        }

        /* Generated JSON section */
        .json-viewer {
            display: none;
            /* Moved logic */
        }
        
        /* Main gradient section in the top editor area */
        .main-gradient-section {
            /* Removed max-height */
            overflow: hidden;
            display: flex;
            flex-direction: column;
            flex: 1;
        }
        
        .gradient-names-section h3 {
            margin-top: 0;
            margin-bottom: 20px;
            flex-shrink: 0;
        }
        
        .gradient-names-list {
            /* Remove fixed height, use flex to fill available space */
            height: auto;
            flex: 1;
            overflow-y: auto;
            background-color: var(--bg-primary);
            border: 1px solid var(--border-dark);
            border-radius: 4px;
            padding: 15px;
        }
        
        .gradient-name-item {
            margin-bottom: 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            overflow: hidden;
            background-color: var(--bg-primary);
        }
        
        .gradient-item-header {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            cursor: pointer;
            background-color: var(--bg-secondary);
            transition: background-color 0.2s;
            text-decoration: none !important; /* Ensure no underline */
        }
        
        .gradient-item-header * {
            text-decoration: none !important;
        }
        
        .gradient-item-header:hover {
            background-color: var(--border-color);
        }
        
        .gradient-name-index {
            font-weight: bold;
            margin-right: 10px;
            color: var(--btn-primary);
        }
        
        .gradient-name {
            flex: 1;
            cursor: pointer;
            text-decoration: underline;
            color: var(--btn-primary);
        }
        
        .gradient-toggle-icon {
            font-size: 12px;
            color: var(--text-secondary);
            transition: transform 0.2s;
        }
        
        .gradient-expandable-content {
            padding: 15px;
            background-color: var(--bg-tertiary);
            border-top: 1px solid var(--border-color);
        }

        .gradient-editor {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            padding: 15px;
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px; /* Rounded corners for the row */
        }
        
        .gradient-editor input[type="number"] {
            padding: 8px 4px; /* Reduced padding to fit text */
            border: 1px solid var(--border-color);
            border-radius: 6px; /* Rounded corners for inputs */
            background-color: var(--bg-input);
            color: var(--text-primary);
            width: 40px; /* Reduced from 60px to 40px (safer than 30px for readability) */
            font-size: 14px;
            text-align: center; /* Center text for better look in small input */
            -moz-appearance: textfield; /* Hide spinner in Firefox */
        }

        /* Hide spinner in Chrome, Safari, Edge, Opera */
        .gradient-editor input[type="number"]::-webkit-outer-spin-button,
        .gradient-editor input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .gradient-editor input[type="color"] {
            width: 60px;
            height: 34px;
            padding: 2px;
            border: 1px solid var(--border-color);
            border-radius: 6px; /* Rounded corners for color picker */
            cursor: pointer;
            background-color: var(--bg-input);
        }
        
        .gradient-data {
            margin: 0;
        }
        
        .gradient-data h4 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 14px;
            color: var(--text-primary);
        }
        
        .gradient-data pre {
            margin: 0;
            padding: 10px;
            background-color: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            overflow-x: auto;
            font-size: 12px;
            line-height: 1.4;
        }
        
        /* Lottie animation container */
        .lottie-animation {
            width: 100%;
            height: 400px;
            background-color: var(--bg-primary);
            border: 1px solid var(--border-dark);
            border-radius: 4px;
            margin-top: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .alpha_checkered {
            background-color: transparent !important;
            background-image: linear-gradient(45deg, var(--checkered-color) 25%, transparent 25%), 
                              linear-gradient(-45deg, var(--checkered-color) 25%, transparent 25%), 
                              linear-gradient(45deg, transparent 75%, var(--checkered-color) 75%), 
                              linear-gradient(-45deg, transparent 75%, var(--checkered-color) 75%) !important;
            background-size: 20px 20px !important;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px !important;
        }
        
        /* Responsive design */
        @media (max-width: 1024px) {
            .playground-container {
                flex-direction: column;
            }
            
            .preview-section,
            .json-editor-section-full,
            .gradient-names-section {
                min-width: auto;
            }
        }
        
        /* Theme transition for smooth changes */
        html {
            transition: background-color 0.3s ease;
        }
        
        /* Additional styles for dark theme */
        [data-theme="dark"] {
            /* Ensure proper contrast for text inputs */
            input[type="text"],
            input[type="number"],
            textarea {
                color: var(--text-primary);
                background-color: var(--bg-input);
            }
            
            /* Improve contrast for scrollbars */
            ::-webkit-scrollbar {
                width: 8px;
                height: 8px;
            }
            
            ::-webkit-scrollbar-track {
                background: var(--bg-secondary);
            }
            
            ::-webkit-scrollbar-thumb {
                background: var(--border-dark);
                border-radius: 4px;
            }
            
            ::-webkit-scrollbar-thumb:hover {
                background: var(--btn-secondary);
            }
        }

        /* Animation Controls */
        .animation-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
            padding: 10px;
            background-color: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }
        
        #animation-progress {
            flex: 1;
            cursor: pointer;
            accent-color: var(--btn-primary);
        }
        
        #time-display {
            font-family: monospace;
            font-size: 12px;
            min-width: 85px;
            text-align: right;
            color: var(--text-primary);
        }

        .bg-controls {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-left: 10px;
            padding-left: 10px;
            border-left: 1px solid var(--border-color);
        }
        
        .bg-color-picker {
            width: 25px;
            height: 25px;
            padding: 0;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            background: none;
        }
        
        .bg-btn {
            width: 25px;
            height: 25px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            background-color: var(--bg-input);
            color: var(--text-primary);
        }
        
        .bg-btn:hover {
            background-color: var(--border-color);
        }
        
        .bg-btn.active {
            background-color: var(--btn-primary);
            color: white;
            border-color: var(--btn-primary);
        }
    </style>
</head>
<body>
    <div class="lottie-player-container">
        <div class="header-container">
            <div class="title-section">
                <h1 style="margin: 0; font-size: 24px;">Lottie渐变编辑器</h1>
            </div>
            
            <div class="controls-section">
                <div class="file-upload">
                    <label for="lottie-file" class="btn btn-flat-primary header-btn file-input-label">
                        <i class="fa-solid fa-upload"></i> 导入 JSON
                    </label>
                    <input type="file" id="lottie-file" class="file-input" accept=".json">
                    <button id="export-btn" class="btn btn-flat-primary header-btn export-btn" style="margin: 0;">
                        <i class="fa-solid fa-download"></i> 导出 JSON
                    </button>
                    <span id="file-info" class="file-info" style="display: none;">未选择文件</span>
                </div>
                
                <button id="theme-toggle" class="btn btn-flat-primary header-btn">
                    <i class="fa-solid fa-moon"></i> 深色模式
                </button>
            </div>
        </div>
        
        <!-- Combined Preview and Editor Section -->
        <div class="playground-container">
            <!-- Left Side: Lottie Animation Preview -->
            <div class="preview-section">
                <div id="lottie-animation" class="lottie-animation alpha_checkered"></div>
                <div class="animation-controls">
                    <button id="play-pause-btn" class="btn btn-secondary btn-sm" title="播放/暂停" style="width: 32px; height: 32px; padding: 0;">
                        <i class="fa-solid fa-pause"></i>
                    </button>
                    <input type="range" id="animation-progress" min="0" max="100" value="0" step="0.1">
                    <span id="time-display">00:00 / 00:00</span>
                    
                    <div class="bg-controls">
                        <input type="color" id="bg-color-picker" class="bg-color-picker" title="背景颜色" value="#ffffff">
                        <button id="bg-alpha-btn" class="bg-btn active" title="透明背景 (Alpha)">
                            <i class="fa-solid fa-border-all"></i>
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Right Side: Editor Section -->
            <div class="editor-section">
                <!-- Gradient List -->
                <div class="gradient-names-section main-gradient-section">
                    <h3>渐变列表</h3>
                    <div id="gradient-names-list" class="gradient-names-list">
                        <p>未找到渐变。上传 JSON 文件以查看渐变。</p>
                    </div>
                </div>
                
                <!-- Color Editor -->
                <div id="editor-container" class="editor-container">
                    <h3 id="editor-title">未选择渐变</h3>
                    <div id="editor"></div>
                </div>
            </div>
            
            <!-- Hidden elements -->
            <div class="json-editor-section-full" style="display: none;">
                <h3>JSON 编辑器</h3>
                <div class="json-editor-controls">
                    <button id="format-json-btn" class="btn btn-primary btn-sm">
                        <i class="fa-solid fa-code"></i> 格式化 JSON
                    </button>
                    <button id="update-animation-btn" class="btn btn-primary btn-sm">
                        <i class="fa-solid fa-play"></i> 更新动画
                    </button>
                </div>
                
                <div class="json-editor-container">
                    <div id="monaco-editor-container"></div>
                    <!-- Fallback textarea for older browsers -->
                    <textarea id="json-editor" placeholder="上传文件或在此处编辑 JSON..." style="display: none;"></textarea>
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden legacy structure -->
    <div class="playground playground-columns" style="display: none;">
        <!-- Left Side: Adobe Gradients -->
        <div class="gradient-names-section main-gradient-section">
            <h3>渐变列表</h3>
            <div id="gradient-names-list-legacy" class="gradient-names-list">
                <p>未找到渐变。上传 JSON 文件以查看渐变。</p>
            </div>
        </div>
        
        <!-- Middle: Color Editor -->
        <div id="editor-legacy"></div>
        
        <!-- Right Side: Generated JSON -->
        <div class="json-viewer">
            <h3>生成的 JSON</h3>
            <pre><code class="language-json" id="json_viewer"></code></pre>
        </div>
    </div>

    <script>
        // Helper functions
        function truncate_float(num) {
            return Math.round(num * 1000) / 1000;
        }

        function color_lottie_to_hex(lottie) {
            let r = Math.round(lottie[0] * 255).toString(16).padStart(2, '0');
            let g = Math.round(lottie[1] * 255).toString(16).padStart(2, '0');
            let b = Math.round(lottie[2] * 255).toString(16).padStart(2, '0');
            return `#${r}${g}${b}`;
        }

        function color_hex_to_lottie(hex) {
            let r = parseInt(hex.slice(1, 3), 16) / 255;
            let g = parseInt(hex.slice(3, 5), 16) / 255;
            let b = parseInt(hex.slice(5, 7), 16) / 255;
            return [r, g, b];
        }

        function color_lottie_to_hex_component(alpha) {
            let a = Math.round(alpha * 255).toString(16).padStart(2, '0');
            return a;
        }

        // GradientPreviewEditor class
        class GradientPreviewEditor {
            constructor(parent, lottie, color_count, on_change, dynamic_count = false) {
                this.on_change = on_change;
                
                // Calculate the correct color count based on Lottie gradient format
                // For gradients without alpha: [offset, r, g, b, offset, r, g, b, ...]
                // For gradients with alpha: [offset, r, g, b, offset, r, g, b, ..., offset, a, offset, a, ...]
                
                let rgbStopCount;
                this.with_alpha = false;
                
                // Check if it's a gradient with alpha
                // For n color stops with alpha, total length is n * 4 + n * 2 = n * 6
                if (lottie.length % 6 === 0) {
                    // Has alpha: each color stop contributes 6 values (4 for RGB, 2 for alpha)
                    this.with_alpha = true;
                    color_count = lottie.length / 6;
                    rgbStopCount = color_count;
                } 
                // Check if it's a gradient without alpha
                // For n color stops without alpha, total length is n * 4
                else if (lottie.length % 4 === 0) {
                    // No alpha: each color stop contributes 4 values (offset, r, g, b)
                    this.with_alpha = false;
                    color_count = lottie.length / 4;
                    rgbStopCount = color_count;
                } 
                else {
                    // Invalid gradient data length
                    console.error('Invalid gradient data length:', lottie.length);
                    // Default to no alpha and calculate color count from length
                    this.with_alpha = false;
                    color_count = Math.floor(lottie.length / 4);
                    rgbStopCount = color_count;
                }

                let self = this;
                this.colors = [];
                // Initialize debounce timer
                this.debounceTimer = null;

                // First create preview container and gradient-preview div
                let preview_cont = parent.appendChild(document.createElement("div"));
                preview_cont.classList.add("alpha_checkered");

                this.preview = preview_cont.appendChild(document.createElement("div"));
                this.preview.classList.add("gradient-preview");
                this.preview.setAttribute("style", "background:" + this.to_css());

                // Then create the label with checkbox
                let label = parent.appendChild(document.createElement("p"))
                    .appendChild(document.createElement("label"));
                this.check_alpha = label.appendChild(document.createElement("input"));
                this.check_alpha.type = "checkbox";
                this.check_alpha.checked = this.with_alpha;
                this.check_alpha.addEventListener("input", () => {
                    self.with_alpha = self.check_alpha.checked;
                    for (let color of self.colors) {
                        color.alpha_input.style.display = self.with_alpha ? "inline-block" : "none";
                    }
                    self._on_change();
                });
                label.appendChild(document.createTextNode(" 启用 Alpha"));

                this.parent = parent.appendChild(document.createElement("div"));
                for (let i = 0; i < color_count; i++) {
                    // Parse RGB values
                    const offset = lottie[i * 4];
                    const rgb = lottie.slice(i * 4 + 1, i * 4 + 4);
                    
                    // Parse alpha value if available
                    let alpha = 1;
                    if (this.with_alpha) {
                        // Alpha data starts after RGB data, each alpha stop has 2 values (offset, alpha)
                        const alphaOffsetIndex = color_count * 4 + i * 2;
                        alpha = lottie[alphaOffsetIndex + 1]; // alpha value is the second in the pair
                    }
                    
                    this.add_color(
                        offset,
                        color_lottie_to_hex(rgb),
                        alpha,
                        dynamic_count
                    );
                }

                if (dynamic_count) {
                    let btn = parent.appendChild(document.createElement("button"));
                    btn.setAttribute("class", "btn btn-success btn-sm");
                    btn.title = "添加色标";
                    btn.innerHTML = "<i class='fa-solid fa-plus'></i> 添加色标";
                    btn.addEventListener("click", () => {
                        self.add_color(1, "#000000", 1, true);
                        self._on_change();
                    });
                }
            }

            add_color(offset, hex, alpha, dynamic_count) {
                let self = this;
                let color = {
                    offset: offset,
                    color: hex,
                    alpha: alpha,
                };
                this.colors.push(color);

                let p = this.parent.appendChild(document.createElement("p"));
                p.classList.add("gradient-editor");
                let in_off = p.appendChild(document.createElement("input"));
                in_off.title = "Offset";
                in_off.type = "number";
                in_off.min = 0;
                in_off.max = 1;
                in_off.step = 0.01;
                in_off.value = color.offset;
                in_off.addEventListener("input", () => {
                    color.offset = Number(in_off.value);
                    // Debounce _on_change to improve performance during drag
                    if (self.debounceTimer) {
                        clearTimeout(self.debounceTimer);
                    }
                    self.debounceTimer = setTimeout(() => {
                        self._on_change();
                    }, 100);
                });

                let in_col = p.appendChild(document.createElement("input"));
                in_col.type = "color";
                in_col.value = color.color;
                in_col.addEventListener("input", () => {
                    color.color = in_col.value;
                    // Debounce _on_change to improve performance during color selection
                    if (self.debounceTimer) {
                        clearTimeout(self.debounceTimer);
                    }
                    self.debounceTimer = setTimeout(() => {
                        self._on_change();
                    }, 100);
                });

                let in_alpha = p.appendChild(document.createElement("input"));
                in_alpha.title = "Alpha";
                in_alpha.type = "number";
                in_alpha.min = 0;
                in_alpha.max = 1;
                in_alpha.step = 0.01;
                in_alpha.value = color.alpha;
                in_alpha.style.display = this.with_alpha ? "inline-block" : "none";
                in_alpha.addEventListener("input", () => {
                    color.alpha = Number(in_alpha.value);
                    // Debounce _on_change to improve performance during alpha adjustment
                    if (self.debounceTimer) {
                        clearTimeout(self.debounceTimer);
                    }
                    self.debounceTimer = setTimeout(() => {
                        self._on_change();
                    }, 100);
                });
                color.alpha_input = in_alpha;

                if (dynamic_count) {
                    let btn = p.appendChild(document.createElement("button"));
                    btn.setAttribute("class", "btn btn-danger btn-sm");
                    btn.title = "删除色标";
                    btn.innerHTML = "<i class='fa-solid fa-minus'></i> 删除";
                    btn.addEventListener("click", () => {
                        self.parent.removeChild(p);
                        self.colors.splice(self.colors.indexOf(color), 1);
                        self._on_change();
                    });
                }
            }

            to_css() {
                let items = [];
                for (let color of this.colors) {
                    let stop = color.color;
                    if (this.with_alpha) {
                        stop += color_lottie_to_hex_component(color.alpha);
                    }
                    stop += " " + (color.offset * 100) + "%";
                    items.push(stop);
                }
                return "linear-gradient(90deg, " + items.join(",") + ")";
            }

            _on_change() {
                let lottie = [];
                let alpha = [];
                for (let color of this.colors) {
                    lottie.push(color.offset, ...color_hex_to_lottie(color.color));
                    if (this.with_alpha) {
                        alpha.push(color.offset, color.alpha);
                    }
                }

                this.preview.setAttribute("style", "background:" + this.to_css());
                this.on_change(lottie.concat(alpha));
            }

            // Method to update the gradient with new data
            update(lottie, color_count) {
                // Clear existing colors and UI
                this.parent.innerHTML = '';
                this.colors = [];
                
                // Calculate the correct color count based on Lottie gradient format
                // For gradients without alpha: [offset, r, g, b, offset, r, g, b, ...]
                // For gradients with alpha: [offset, r, g, b, offset, r, g, b, ..., offset, a, offset, a, ...]
                
                let rgbStopCount;
                this.with_alpha = false;
                
                // Check if it's a gradient with alpha
                // For n color stops with alpha, total length is n * 4 + n * 2 = n * 6
                if (lottie.length % 6 === 0) {
                    // Has alpha: each color stop contributes 6 values (4 for RGB, 2 for alpha)
                    this.with_alpha = true;
                    color_count = lottie.length / 6;
                    rgbStopCount = color_count;
                } 
                // Check if it's a gradient without alpha
                // For n color stops without alpha, total length is n * 4
                else if (lottie.length % 4 === 0) {
                    // No alpha: each color stop contributes 4 values (offset, r, g, b)
                    this.with_alpha = false;
                    color_count = lottie.length / 4;
                    rgbStopCount = color_count;
                } 
                else {
                    // Invalid gradient data length
                    console.error('Invalid gradient data length:', lottie.length);
                    // Default to no alpha and calculate color count from length
                    this.with_alpha = false;
                    color_count = Math.floor(lottie.length / 4);
                    rgbStopCount = color_count;
                }
                
                // Recreate color inputs
                for (let i = 0; i < color_count; i++) {
                    // Parse RGB values
                    const offset = lottie[i * 4];
                    const rgb = lottie.slice(i * 4 + 1, i * 4 + 4);
                    
                    // Parse alpha value if available
                    let alpha = 1;
                    if (this.with_alpha) {
                        // Alpha data starts after RGB data, each alpha stop has 2 values (offset, alpha)
                        const alphaOffsetIndex = color_count * 4 + i * 2;
                        alpha = lottie[alphaOffsetIndex + 1]; // alpha value is the second in the pair
                    }
                    
                    this.add_color(
                        offset,
                        color_lottie_to_hex(rgb),
                        alpha,
                        true // dynamic_count
                    );
                }
                
                // Update the preview
                this._on_change();
                
                // Update the checkbox state to match with_alpha property
                if (this.check_alpha) {
                    this.check_alpha.checked = this.with_alpha;
                }
            }
            
            static stand_alone(parent, on_change) {
                let initial = [0, 0.161, 0.184, 0.459, 0.5, 0.196, 0.314, 0.69, 1, 0.769, 0.851, 0.961];
                on_change(initial);
                return new GradientPreviewEditor(parent, initial, 3, on_change, true);
            }
        }

        // Initialize the editor when the page loads
        let gradientEditorInstance = null;
        let selectedGradientInfo = null; // Store information about the currently selected gradient
        let monacoEditor = null; // Global reference to Monaco Editor
        let animation = null; // Global reference to Lottie animation
        
        document.addEventListener('DOMContentLoaded', () => {
            // Theme Toggle Logic
            const themeToggle = document.getElementById('theme-toggle');
            const body = document.body;
            
            // Check for saved theme in localStorage or use system preference
            const savedTheme = localStorage.getItem('theme');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            
            // Set initial theme
            const initialTheme = savedTheme || (prefersDark ? 'dark' : 'light');
            body.setAttribute('data-theme', initialTheme);
            
            // Update button text and icon based on current theme
            const updateThemeButton = () => {
                const currentTheme = body.getAttribute('data-theme');
                if (currentTheme === 'dark') {
                    themeToggle.innerHTML = '<i class="fa-solid fa-sun"></i> 浅色模式';
                } else {
                    themeToggle.innerHTML = '<i class="fa-solid fa-moon"></i> 深色模式';
                }
            };
            
            // Call once to set initial button state
            updateThemeButton();
            
            // Add click event listener for theme toggle
            themeToggle.addEventListener('click', () => {
                const currentTheme = body.getAttribute('data-theme');
                const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                
                // Update theme attribute on body
                body.setAttribute('data-theme', newTheme);
                
                // Save theme preference to localStorage
                localStorage.setItem('theme', newTheme);
                
                // Update button text and icon
                updateThemeButton();
            });
            
            // Initialize Gradient Editor
            gradientEditorInstance = GradientPreviewEditor.stand_alone(document.getElementById("editor"), (lottie) => {
                var raw_json = JSON.stringify(lottie, undefined, 4);
                document.getElementById("json_viewer").innerHTML = raw_json;
                
                // If a gradient is selected, update it in the JSON editor
                if (selectedGradientInfo) {
                    updateGradientInJson(lottie);
                }
            });

            // Initialize Lottie Player
            initializeLottiePlayer();
        });
        
        // Function to update the selected gradient in the JSON editor
        function updateGradientInJson(newGradientData) {
            // Get current JSON content from Monaco Editor
            if (monacoEditor) {
                try {
                    const jsonContent = monacoEditor.getValue();
                    const jsonData = JSON.parse(jsonContent);
                    
                    // Find and update the gradient in the JSON data
                    updateGradientInJsonData(jsonData, selectedGradientInfo, newGradientData);
                    
                    // Update the Monaco Editor with the modified JSON
                    const updatedJsonContent = JSON.stringify(jsonData, null, 2);
                    monacoEditor.setValue(updatedJsonContent);
                    
                    // Auto-update the animation preview
                    updateAnimationFromEditor();
                } catch (error) {
                    console.error('Error updating gradient in JSON:', error);
                }
            }
        }
        
        // Recursive function to find and update the gradient in JSON data
        function updateGradientInJsonData(jsonData, gradientInfo, newGradientData) {
            let updated = false;
            // Check if this is the object containing the gradient
            if (typeof jsonData === 'object' && jsonData !== null) {
                // If it's the gradient object, update its "k" property
                if (jsonData.ty === 'gf' && jsonData.nm === gradientInfo.name) {
                    if (jsonData.g) {
                        // Calculate new color count correctly
                        // Gradient data format: [offset1, r1, g1, b1, offset2, r2, g2, b2, ..., offset1, alpha1, offset2, alpha2, ...]
                        // So first part is RGB data (color_count * 4), then alpha data (color_count * 2) if alpha is enabled
                        // For color_count color stops:
                        // - Without alpha: length = color_count * 4
                        // - With alpha: length = color_count * 4 + color_count * 2 = color_count * 6
                        
                        // The correct way to calculate color count is to always divide by 4
                        // because the RGB data is always the first part of the array
                        // and each color stop has exactly 4 values in the RGB data
                        // This works for both cases:
                        // - Without alpha: length / 4 = color_count
                        // - With alpha: length = color_count * 6, so length / 4 = color_count * 1.5
                        // Wait, no! That's wrong. Wait, no. Wait, for 2 color stops with alpha, length is 12
                        // 12 / 4 = 3, but there are only 2 color stops. Oh, right! So that's wrong.
                        
                        // So I need to calculate it differently. Let's think:
                        // When we have alpha enabled, we have color_count color stops, and for each color stop,
                        // we have 4 values in RGB data and 2 values in alpha data. So total length is color_count * 6.
                        // When we have alpha disabled, we have color_count color stops, and for each color stop,
                        // we have 4 values in RGB data. So total length is color_count * 4.
                        
                        // So if the length is divisible by 6, then it's a gradient with alpha, and color_count = length / 6.
                        // If the length is divisible by 4, then it's a gradient without alpha, and color_count = length / 4.
                        // If neither, then we have an invalid gradient data length.
                        
                        // But wait, let's look at the _on_change method to see how the gradient data is generated:
                        // _on_change() {
                        //     let lottie = [];
                        //     let alpha = [];
                        //     for (let color of this.colors) {
                        //         lottie.push(color.offset, ...color_hex_to_lottie(color.color));
                        //         if (this.with_alpha) {
                        //             alpha.push(color.offset, color.alpha);
                        //         }
                        //     }
                        //     this.on_change(lottie.concat(alpha));
                        // }
                        // So for n color stops, with alpha enabled, lottie has n * 4 values, alpha has n * 2 values.
                        // So total length is n * 4 + n * 2 = n * 6, which is divisible by 6.
                        // With alpha disabled, alpha is empty, so total length is n * 4, which is divisible by 4.
                        // So the gradient data should always have a length divisible by 4 or 6.
                        
                        // So the correct way to calculate color_count is:
                        let newColorCount;
                        if (newGradientData.length % 6 === 0) {
                            // Has alpha: each color stop contributes 6 values
                            newColorCount = newGradientData.length / 6;
                        } else if (newGradientData.length % 4 === 0) {
                            // No alpha: each color stop contributes 4 values
                            newColorCount = newGradientData.length / 4;
                        } else {
                            // Invalid gradient data length
                            console.error('Invalid gradient data length:', newGradientData.length);
                            return updated;
                        }
                        
                        // Update the gradient data
                        if (jsonData.g.k && typeof jsonData.g.k === 'object' && 'k' in jsonData.g.k) {
                            // Handle nested k structure: g.k is an object with a k property
                            jsonData.g.k.k = newGradientData;
                            // Update the color count (p property) in the gradient
                            if (jsonData.g.p !== undefined) {
                                jsonData.g.p = newColorCount;
                            }
                        } else {
                            // Handle direct k structure: g.k is the array directly
                            jsonData.g.k = newGradientData;
                            // Update the color count (p property) in the gradient
                            if (jsonData.g.p !== undefined) {
                                jsonData.g.p = newColorCount;
                            }
                        }
                        updated = true;
                    }
                }
                
                // Recursively check all properties
                for (const key in jsonData) {
                    if (jsonData.hasOwnProperty(key)) {
                        const value = jsonData[key];
                        if (typeof value === 'object' && value !== null) {
                            if (updateGradientInJsonData(value, gradientInfo, newGradientData)) {
                                updated = true;
                            }
                        }
                    }
                }
            } else if (Array.isArray(jsonData)) {
                // Check each item in the array
                for (const item of jsonData) {
                    if (updateGradientInJsonData(item, gradientInfo, newGradientData)) {
                        updated = true;
                    }
                }
            }
            return updated;
        }

        // Lottie Player and JSON Editor functions
        function initializeLottiePlayer() {
            let debounceTimer = null;
            const fileInput = document.getElementById('lottie-file');
            const fileInfo = document.getElementById('file-info');
            const animationContainer = document.getElementById('lottie-animation');
            const jsonEditor = document.getElementById('json-editor');
            const formatJsonBtn = document.getElementById('format-json-btn');
            const updateAnimationBtn = document.getElementById('update-animation-btn');
            
            // Animation controls
            const playPauseBtn = document.getElementById('play-pause-btn');
            const progressBar = document.getElementById('animation-progress');
            const timeDisplay = document.getElementById('time-display');
            const playIcon = '<i class="fa-solid fa-play"></i>';
            const pauseIcon = '<i class="fa-solid fa-pause"></i>';
            let isDragging = false;
            
            // Background controls
            const bgColorPicker = document.getElementById('bg-color-picker');
            const bgAlphaBtn = document.getElementById('bg-alpha-btn');
            
            // Editor title
            const editorTitle = document.getElementById('editor-title');
            
            // Initialize Monaco Editor
            function initMonacoEditor() {
                require.config({
                    paths: {
                        'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.41.0/min/vs'
                    }
                });

                require(['vs/editor/editor.main'], function() {
                    // Ensure the container has proper dimensions before initializing
                    const container = document.getElementById('monaco-editor-container');
                    
                    // Force the container to have the correct height
                    container.style.display = 'block';
                    container.style.width = '100%';
                    container.style.height = '400px';
                    
                    monacoEditor = monaco.editor.create(container, {
                        value: '',
                        language: 'json',
                        theme: 'vs',
                        automaticLayout: true,
                        minimap: {
                            enabled: true
                        },
                        scrollBeyondLastLine: false,
                        wordWrap: 'on',
                        formatOnPaste: true,
                        formatOnType: true,
                        tabSize: 2,
                        lineNumbers: 'on',
                        glyphMargin: true,
                        folding: true,
                        scrollbar: {
                            vertical: 'visible',
                            horizontal: 'visible',
                            useShadows: false
                        }
                    });

                    // Add JSON validation
                    monaco.languages.json.jsonDefaults.setDiagnosticsOptions({
                        validate: true,
                        schemas: []
                    });
                    
                    // Update editor when window is resized
                    window.addEventListener('resize', function() {
                        monacoEditor.layout();
                    });
                    
                    // Add change listener for auto-update functionality
                    monacoEditor.onDidChangeModelContent(function() {
                        // Auto-update animation when editor content changes
                        // Use debounce to avoid excessive updates
                        if (debounceTimer) {
                            clearTimeout(debounceTimer);
                        }
                        debounceTimer = setTimeout(function() {
                            updateAnimationFromEditor();
                            // Update gradient names list when editor content changes
                            updateGradientNamesList();
                        }, 500); // 500ms debounce
                    });
                });
            }
            
            // Initialize Monaco Editor when DOM is ready and container is properly sized
            if (typeof require !== 'undefined') {
                // Use setTimeout to ensure DOM is fully rendered
                setTimeout(initMonacoEditor, 100);
            } else {
                // Fallback if require is not available (older browsers)
                document.getElementById('json-editor').style.display = 'block';
                document.getElementById('monaco-editor-container').style.display = 'none';
            }
            
            // Add a check to ensure editor content is properly synced
            function ensureContentSynced() {
                if (monacoEditor && jsonEditor.value !== monacoEditor.getValue()) {
                    console.log('Syncing textarea with Monaco Editor content');
                    jsonEditor.value = monacoEditor.getValue();
                }
            }
            
            // Sync content every second for safety
            setInterval(ensureContentSynced, 1000);

            // Function to load and play Lottie animation
            function loadAnimation(jsonData) {
                try {
                    console.log('Loading animation with data:', JSON.stringify(jsonData).substring(0, 100) + '...');
                    
                    // Destroy existing animation if any
                    if (animation) {
                        console.log('Destroying existing animation');
                        animation.destroy();
                        animation = null;
                    }

                    // Reset controls
                    if (playPauseBtn) playPauseBtn.innerHTML = pauseIcon;
                    if (progressBar) progressBar.value = 0;

                    // Load new animation
                    console.log('Creating new animation with bodymovin');
                    animation = bodymovin.loadAnimation({
                        container: animationContainer,
                        renderer: 'svg',
                        loop: true,
                        autoplay: true,
                        animationData: jsonData
                    });
                    console.log('Animation created successfully');
                    
                    // Add animation event listeners for debugging
                    animation.addEventListener('DOMLoaded', () => {
                        console.log('Animation DOMLoaded event fired');
                        updateTimeDisplay();
                    });
                    
                    animation.addEventListener('enterFrame', () => {
                        if (!isDragging && animation && progressBar) {
                            const progress = (animation.currentFrame / animation.totalFrames) * 100;
                            progressBar.value = progress;
                            updateTimeDisplay();
                        }
                    });
                    
                    animation.addEventListener('loopComplete', () => {
                        console.log('Animation loopComplete event fired');
                    });
                    
                    animation.addEventListener('complete', () => {
                        console.log('Animation complete event fired');
                        if (playPauseBtn) playPauseBtn.innerHTML = playIcon;
                    });
                    
                    animation.addEventListener('error', (error) => {
                        console.error('Animation error event fired:', error);
                    });
                    
                } catch (error) {
                    console.error('Error loading animation:', error);
                    alert('Error loading animation: ' + error.message);
                }
            }

            // Function to update JSON editor content
            function updateJsonEditor(jsonData) {
                const jsonString = JSON.stringify(jsonData, undefined, 2);
                console.log('Updating JSON editor with content:', jsonString.substring(0, 100) + (jsonString.length > 100 ? '...' : ''));
                
                if (monacoEditor) {
                    monacoEditor.setValue(jsonString);
                    console.log('Monaco Editor content updated successfully');
                }
                jsonEditor.value = jsonString;
            }

            // Function to get JSON content from editor
            function getJsonContent() {
                let content = '';
                
                // Check if Monaco Editor is available and has content
                if (monacoEditor) {
                    try {
                        content = monacoEditor.getValue();
                        console.log('Got content from Monaco Editor, length:', content.length);
                    } catch (e) {
                        console.error('Error getting content from Monaco Editor:', e.message);
                        // Fallback to textarea
                        content = jsonEditor.value;
                    }
                } else {
                    content = jsonEditor.value;
                }
                
                // Ensure we have valid content
                if (!content.trim()) {
                    console.log('Content is empty, returning empty string');
                }
                
                return content;
            }
            
            // Function to format JSON in editor
            function formatJson() {
                const jsonText = getJsonContent();
                if (jsonText.trim() === '') {
                    return;
                }

                try {
                    const jsonData = JSON.parse(jsonText);
                    updateJsonEditor(jsonData);
                    
                    // If Monaco Editor is available, use its format command
                    if (monacoEditor) {
                        monacoEditor.getAction('editor.action.formatDocument').run();
                    }
                } catch (error) {
                    console.error('Error formatting JSON:', error);
                    alert('Invalid JSON format. Please check your JSON and try again.');
                }
            }

            // Function to find all Adobe gradient names in JSON
            function findAdobeGradientNames(jsonData) {
                const gradients = [];
                const foundNames = new Set(); // Use Set to track unique gradient names
                
                // Recursive function to traverse JSON and find gradients with their "g" data
                function traverse(obj, parent = null, path = []) {
                    if (obj === null || typeof obj !== 'object') {
                        return;
                    }
                    
                    // Check if this is a gradient fill object
                    if (obj.ty === 'gf' && obj.mn === 'ADBE Vector Graphic - G-Fill' && obj.nm) {
                        const name = obj.nm;
                        // Only add each gradient name once, regardless of how many times it appears
                        if (!foundNames.has(name)) {
                            foundNames.add(name);
                            gradients.push({
                                name: name,
                                gradientData: obj.g || {}, // Store the "g" tag content
                                parent: parent,
                                path: path.join('.') // Store the path for debugging
                            });
                        }
                    }
                    
                    // If this object has a shapes array, check its items
                    if (obj.shapes && Array.isArray(obj.shapes)) {
                        for (const shape of obj.shapes) {
                            traverse(shape, obj, [...path, 'shapes']);
                        }
                    }
                    
                    // If this is an array, check all items
                    if (Array.isArray(obj)) {
                        for (let i = 0; i < obj.length; i++) {
                            traverse(obj[i], obj, [...path, i]);
                        }
                    }
                    
                    // If this is an object, check all properties
                    else if (typeof obj === 'object') {
                        for (const key in obj) {
                            traverse(obj[key], obj, [...path, key]);
                        }
                    }
                }
                
                // Start traversal
                traverse(jsonData);
                
                return gradients;
            }
            
            // Function to update gradient names list
            function updateGradientNamesList() {
                const gradientNamesList = document.getElementById('gradient-names-list');
                
                try {
                    // First try to use animationData (already parsed JSON from animation)
                    if (animation && animation.animationData) {
                        console.log('Using animationData for gradient names');
                        const gradients = findAdobeGradientNames(animation.animationData);
                        
                        if (gradients.length === 0) {
                            gradientNamesList.innerHTML = '<p>JSON 文件中未找到渐变。</p>';
                        } else {
                            // Clear existing content
                            gradientNamesList.innerHTML = '';
                            
                            // Create and add gradient items
                            gradients.forEach((gradient, index) => {
                                // Create main gradient item
                                const gradientItem = document.createElement('div');
                                gradientItem.className = 'gradient-name-item';
                                gradientItem.innerHTML = `
                                    <div class="gradient-item-header">
                                        <span class="gradient-name">${gradient.name}</span>
                                    </div>
                                `;
                                
                                // Add click event for navigation
                                const gradientHeader = gradientItem.querySelector('.gradient-item-header');
                                gradientHeader.addEventListener('click', function() {
                                    const gradientName = gradient.name;
                                    console.log('Clicked gradient:', gradientName);
                                    
                                    // Store information about the selected gradient
                                    selectedGradientInfo = {
                                        name: gradient.name,
                                        gradientData: gradient.gradientData
                                    };
                                    
                                    // Update Editor Title
                                    if (editorTitle) {
                                        editorTitle.textContent = gradient.name;
                                    }
                                    
                                    // Update Gradient Editor with the clicked gradient's data
                                    if (gradientEditorInstance && gradient.gradientData && gradient.gradientData.k) {
                                        console.log('Updating Gradient Editor with:', gradient.gradientData);
                                        const gradientData = gradient.gradientData;
                                        
                                        // Handle both direct array format and nested object format for k
                                        let gradientK = gradientData.k;
                                        if (typeof gradientK === 'object' && gradientK !== null && gradientK.k) {
                                            // Nested format: k.k contains the actual color stops
                                            gradientK = gradientK.k;
                                        }
                                        
                                        // Calculate color stop count
                                        const colorCount = gradientData.p || Math.floor(gradientK.length / 4);
                                        gradientEditorInstance.update(gradientK, colorCount);
                                    }
                                    
                                    if (monacoEditor) {
                                        console.log('Using Monaco Editor for navigation');
                                        
                                        // Get editor content
                                        const content = monacoEditor.getValue();
                                        
                                        // Find the gradient in the content
                                        const searchText = `"nm":"${gradientName}"`;
                                        const index = content.indexOf(searchText);
                                        
                                        if (index !== -1) {
                                            console.log('Found gradient at index:', index);
                                            
                                            // Calculate line and column
                                            const lines = content.substring(0, index).split('\n');
                                            const line = lines.length - 1;
                                            const column = lines[line].length;
                                            
                                            console.log('Line:', line, 'Column:', column);
                                            
                                            // Set selection and reveal
                                            monacoEditor.setPosition({ lineNumber: line + 1, column: column + 1 });
                                            monacoEditor.revealPositionInCenter({ lineNumber: line + 1, column: column + 1 });
                                            monacoEditor.focus();
                                            
                                            console.log('Navigation completed');
                                        } else {
                                            console.log('Gradient not found in content');
                                        }
                                    } else {
                                        console.log('Monaco Editor not available');
                                    }
                                });
                                
                                // Add hover effect
                                gradientItem.style.cursor = 'pointer';
                                gradientItem.style.transition = 'background-color 0.2s';
                                gradientItem.addEventListener('mouseenter', () => {
                                    gradientItem.style.backgroundColor = '#f0f0f0';
                                });
                                gradientItem.addEventListener('mouseleave', () => {
                                    gradientItem.style.backgroundColor = 'transparent';
                                });
                                
                                // Add to list
                                gradientNamesList.appendChild(gradientItem);
                            });
                        }
                        return;
                    }
                    
                    // If no animationData, try to get from editor
                    const jsonText = getJsonContent();
                    if (jsonText.trim() === '') {
                        gradientNamesList.innerHTML = '<p>未找到渐变。上传 JSON 文件以查看渐变。</p>';
                        return;
                    }
                    
                    // Try to parse JSON from editor content
                    const jsonData = JSON.parse(jsonText);
                    const gradients = findAdobeGradientNames(jsonData);
                    
                    if (gradients.length === 0) {
                        gradientNamesList.innerHTML = '<p>JSON 文件中未找到渐变。</p>';
                    } else {
                        // Clear existing content
                        gradientNamesList.innerHTML = '';
                        
                        // Create and add gradient items with expand/collapse functionality
                        gradients.forEach((gradient, index) => {
                            // Create main gradient item
                            const gradientItem = document.createElement('div');
                            gradientItem.className = 'gradient-name-item';
                            gradientItem.innerHTML = `
                                <div class="gradient-item-header">
                                    <span class="gradient-name-index">${index + 1}.</span>
                                    <span class="gradient-name">${gradient.name}</span>
                                </div>
                            `;
                            
                            // Add click event for navigation
                            const gradientNameElement = gradientItem.querySelector('.gradient-name');
                            gradientNameElement.addEventListener('click', function() {
                                const gradientName = gradient.name;
                                console.log('Clicked gradient:', gradientName);
                                
                                // Update Gradient Editor with the clicked gradient's data
                                if (gradientEditorInstance && gradient.gradientData && gradient.gradientData.k) {
                                    console.log('Updating Gradient Editor with:', gradient.gradientData);
                                    const gradientData = gradient.gradientData;
                                    
                                    // Handle both direct array format and nested object format for k
                                    let gradientK = gradientData.k;
                                    if (typeof gradientK === 'object' && gradientK !== null && gradientK.k) {
                                        // Nested format: k.k contains the actual color stops
                                        gradientK = gradientK.k;
                                    }
                                    
                                    // Calculate color stop count
                                    const colorCount = gradientData.p || Math.floor(gradientK.length / 4);
                                    gradientEditorInstance.update(gradientK, colorCount);
                                }
                                
                                if (monacoEditor) {
                                    console.log('Using Monaco Editor for navigation');
                                    
                                    // Get editor content
                                    const content = monacoEditor.getValue();
                                    
                                    // Find the gradient in the content
                                    const searchText = `"nm":"${gradientName}"`;
                                    const index = content.indexOf(searchText);
                                    
                                    if (index !== -1) {
                                        console.log('Found gradient at index:', index);
                                        
                                        // Calculate line and column
                                        const lines = content.substring(0, index).split('\n');
                                        const line = lines.length - 1;
                                        const column = lines[line].length;
                                        
                                        console.log('Line:', line, 'Column:', column);
                                        
                                        // Set selection and reveal
                                        monacoEditor.setPosition({ lineNumber: line + 1, column: column + 1 });
                                        monacoEditor.revealPositionInCenter({ lineNumber: line + 1, column: column + 1 });
                                        monacoEditor.focus();
                                        
                                        console.log('Navigation completed');
                                    } else {
                                        console.log('Gradient not found in content');
                                    }
                                } else {
                                    console.log('Monaco Editor not available');
                                }
                            });
                            
                            // Add hover effect
                            gradientItem.style.cursor = 'pointer';
                            gradientItem.style.transition = 'background-color 0.2s';
                            gradientItem.addEventListener('mouseenter', () => {
                                gradientItem.style.backgroundColor = '#f0f0f0';
                            });
                            gradientItem.addEventListener('mouseleave', () => {
                                gradientItem.style.backgroundColor = 'transparent';
                            });
                            
                            // Add to list
                            gradientNamesList.appendChild(gradientItem);
                        });
                    }
                } catch (error) {
                    console.error('updateGradientNamesList 错误:', error.message);
                    // 显示友好的错误信息，而不是无效的 JSON
                    gradientNamesList.innerHTML = '<p>JSON 文件中未找到渐变。</p>';
                }
            }
            
            // Function to update animation from JSON editor
            function updateAnimationFromEditor() {
                const jsonText = getJsonContent();
                if (jsonText.trim() === '') {
                    alert('请先输入或上传 JSON 文件。');
                    return;
                }

                try {
                    console.log('Attempting to parse JSON:', jsonText.substring(0, 100) + (jsonText.length > 100 ? '...' : ''));
                    const jsonData = JSON.parse(jsonText);
                    console.log('JSON parsed successfully, updating animation');
                    loadAnimation(jsonData);
                    // Update gradient names list
                    updateGradientNamesList();
                } catch (error) {
                    console.error('从编辑器解析 JSON 错误:', error);
                    // 提供更详细的错误信息
                    let errorMessage = '编辑器中的 JSON 无效。请检查您的 JSON 并重试。\n\n';
                    errorMessage += `错误: ${error.message}\n`;
                    if (error.stack) {
                        errorMessage += `堆栈跟踪: ${error.stack}\n`;
                    }
                    errorMessage += `\n内容的前 100 个字符: ${jsonText.substring(0, 100)}${jsonText.length > 100 ? '...' : ''}`;
                    
                    // 用于友好的用户提示
                    alert('编辑器中的 JSON 无效。请检查您的 JSON 并重试。\n\n' + error.message);
                    console.error(errorMessage);
                    // 用错误信息更新渐变名称列表
                    updateGradientNamesList();
                }
            }

            // Handle file upload
            fileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    // Update file info
                    fileInfo.textContent = `Selected file: ${file.name}`;

                    // Read file
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            // Parse JSON
                            const jsonData = JSON.parse(e.target.result);
                            console.log('Successfully parsed JSON file, data type:', typeof jsonData);
                            
                            // Load animation
                            loadAnimation(jsonData);
                            // Update JSON editor
                            updateJsonEditor(jsonData);
                            
                            // Update gradient names list - use the new reliable function
                            updateGradientNamesList();
                            
                        } catch (error) {
                            console.error('Error parsing JSON file:', error);
                            alert('无效的 JSON 文件。请选择有效的 Lottie JSON 文件。');
                            fileInfo.textContent = '未选择文件';
                            jsonEditor.value = '';
                            if (animation) {
                                animation.destroy();
                                animation = null;
                            }
                            // Reset gradient names list
                            const gradientNamesList = document.getElementById('gradient-names-list');
                            gradientNamesList.innerHTML = '<p>未找到渐变。上传 JSON 文件以查看渐变。</p>';
                            
                            // Reset editor title
                            if (editorTitle) editorTitle.textContent = '未选择渐变';
                        }
                    };
                    reader.readAsText(file);
                } else {
                    // 重置文件信息
                    fileInfo.textContent = '未选择文件';
                    jsonEditor.value = '';
                    if (animation) {
                        animation.destroy();
                        animation = null;
                    }
                    // 重置渐变名称列表
                    const gradientNamesList = document.getElementById('gradient-names-list');
                    gradientNamesList.innerHTML = '<p>未找到渐变。上传 JSON 文件以查看渐变。</p>';
                    
                    // Reset editor title
                    if (editorTitle) editorTitle.textContent = '未选择渐变';
                }
            });

            // Event listeners for JSON editor buttons
            formatJsonBtn.addEventListener('click', () => {
                // Call formatJson function
                formatJson();
                
                // Update gradient names list after formatting
                // Use a setTimeout to ensure the editor content is updated
                setTimeout(() => {
                    updateGradientNamesList();
                }, 100);
            });
            updateAnimationBtn.addEventListener('click', updateAnimationFromEditor);
            
            // Export functionality
            const exportBtn = document.getElementById('export-btn');
            exportBtn.addEventListener('click', () => {
                const jsonContent = getJsonContent();
                if (!jsonContent.trim()) {
                    alert('No JSON content to export.');
                    return;
                }
                
                // Create a download link
                const blob = new Blob([jsonContent], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `lottie-gradient-${new Date().getTime()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });
            
            // Helper function to update time display
            function updateTimeDisplay() {
                if (!animation) return;
                // Get total frames and frame rate
                const totalFrames = animation.totalFrames || 0;
                const frameRate = animation.frameRate || 30;
                const currentFrame = animation.currentFrame || 0;
                
                const currentTime = currentFrame / frameRate;
                const totalTime = totalFrames / frameRate;
                
                if (timeDisplay) {
                    timeDisplay.textContent = `${formatTime(currentTime)} / ${formatTime(totalTime)}`;
                }
            }
            
            function formatTime(seconds) {
                if (!isFinite(seconds) || isNaN(seconds)) return "00:00";
                const m = Math.floor(seconds / 60);
                const s = Math.floor(seconds % 60);
                return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            }

            // Animation Control Event Listeners
            if (playPauseBtn) {
                playPauseBtn.addEventListener('click', () => {
                    if (!animation) return;
                    if (animation.isPaused) {
                        animation.play();
                        playPauseBtn.innerHTML = pauseIcon;
                    } else {
                        animation.pause();
                        playPauseBtn.innerHTML = playIcon;
                    }
                });
            }
            
            if (progressBar) {
                progressBar.addEventListener('input', () => {
                    isDragging = true;
                    if (!animation) return;
                    const frame = (progressBar.value / 100) * animation.totalFrames;
                    animation.goToAndStop(frame, true);
                    updateTimeDisplay();
                });
                
                progressBar.addEventListener('change', () => {
                    isDragging = false;
                    if (!animation) return;
                    // If the button shows pause icon, it means it should be playing
                    if (playPauseBtn && playPauseBtn.innerHTML.includes('fa-pause')) {
                        animation.play();
                    }
                });
            }
            
            // Background Control Event Listeners
            if (bgColorPicker && bgAlphaBtn) {
                // Initial state
                if (animationContainer.classList.contains('alpha_checkered')) {
                    bgAlphaBtn.classList.add('active');
                } else {
                    // Try to get background color
                    const style = window.getComputedStyle(animationContainer);
                    // Use a simple default or try to parse
                }

                bgColorPicker.addEventListener('input', (e) => {
                    const color = e.target.value;
                    animationContainer.style.backgroundColor = color;
                    animationContainer.classList.remove('alpha_checkered');
                    bgAlphaBtn.classList.remove('active');
                });
                
                bgAlphaBtn.addEventListener('click', () => {
                    if (animationContainer.classList.contains('alpha_checkered')) {
                        // If already active, switch back to color
                        animationContainer.classList.remove('alpha_checkered');
                        bgAlphaBtn.classList.remove('active');
                        animationContainer.style.backgroundColor = bgColorPicker.value;
                    } else {
                        // Enable alpha
                        animationContainer.classList.add('alpha_checkered');
                        bgAlphaBtn.classList.add('active');
                        // Clear background color to let pattern show
                        animationContainer.style.backgroundColor = 'transparent';
                    }
                });
            }
            
            // Expose functions to global scope so they can be called from outside initializeLottiePlayer
            window.getJsonContent = getJsonContent;
            window.loadAnimation = loadAnimation;
            window.updateGradientNamesList = updateGradientNamesList;
            window.updateAnimationFromEditor = updateAnimationFromEditor;
        }
    </script>
</body>
</html>